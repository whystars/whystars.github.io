<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whystars</title>
  
  <subtitle>blog</subtitle>
  <link href="https://whystars.cn/atom.xml" rel="self"/>
  
  <link href="https://whystars.cn/"/>
  <updated>2025-05-03T06:36:33.180Z</updated>
  <id>https://whystars.cn/</id>
  
  <author>
    <name>whystars</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>L8.5 - 数学专题：杨辉三角的编程妙用（拓展）</title>
    <link href="https://whystars.cn/posts/b0e0.html"/>
    <id>https://whystars.cn/posts/b0e0.html</id>
    <published>2025-05-03T04:09:50.000Z</published>
    <updated>2025-05-03T06:36:33.180Z</updated>
    
    <content type="html"><![CDATA[<h1>L8.5 - 数学专题：杨辉三角的编程妙用（拓展）</h1><hr><h2 id="一、杨辉三角是什么？">一、杨辉三角是什么？</h2><h3 id="1-数字金字塔">1. 数字金字塔</h3><p><strong>外观特点</strong>：<br>每一行数字左右对称，像金字塔一样逐层增加<br>第n行有n个数字，首尾都是1，中间数字=上层两数之和</p><p><strong>示例</strong>（前5行）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    1  </span></span><br><span class="line"><span class="code">   1 1  </span></span><br><span class="line"><span class="code">  1 2 1  </span></span><br><span class="line"><span class="code"> 1 3 3 1  </span></span><br><span class="line"><span class="code">1 4 6 4 1</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、用C-生成杨辉三角">二、用C++生成杨辉三角</h2><h3 id="1-二维数组生成法">1. 二维数组生成法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generatePascal</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">triangle</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        triangle[i].<span class="built_in">resize</span>(i+<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 每行初始化为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第三行开始计算中间数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;i; j++) &#123; </span><br><span class="line">            triangle[i][j] = triangle[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> triangle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tri = <span class="built_in">generatePascal</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; row : tri) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : row) </span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、杨辉三角的编程妙用">三、杨辉三角的编程妙用</h2><h3 id="1-快速查组合数">1. 快速查组合数</h3><p><strong>秘密</strong>：第n行第k个数 = 从(n-1)个物品选(k-1)个的组合数 C(n-1, k-1)</p><p><strong>应用示例</strong>：查C(4,2)=6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> tri = <span class="built_in">generatePascal</span>(<span class="number">5</span>); <span class="comment">// 生成前5行</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C(4,2) = &quot;</span> &lt;&lt; tri[<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">// 输出第5行第3个数 → 6</span></span><br></pre></td></tr></table></figure><h3 id="2-多项式展开系数">2. 多项式展开系数</h3><p><strong>二项式定理</strong>：<br>(a + b) ^ n的展开系数 = 杨辉三角第(n + 1)行</p><p><strong>示例</strong>：<br>(a + b) ^ 3 = 1a³ + 3a²b + 3ab² + 1b³<br>对应杨辉三角第4行：1 3 3 1</p><hr><h2 id="四、趣味编程挑战">四、趣味编程挑战</h2><h3 id="1-打印圣诞树">1. 打印圣诞树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printChristmasTree</span><span class="params">(<span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tri = <span class="built_in">generatePascal</span>(height);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; row : tri) &#123;</span><br><span class="line">        <span class="comment">// 添加空格形成树形</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(height - row.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : row) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">printChristmasTree</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-数字金字塔游戏">2. 数字金字塔游戏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断用户输入的金字塔是否正确</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPascal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; userInput)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;userInput.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(userInput[i][j] != userInput[i<span class="number">-1</span>][j<span class="number">-1</span>]+userInput[i<span class="number">-1</span>][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、核心知识点总结">五、核心知识点总结</h2><table><thead><tr><th>内容</th><th>关键点</th><th>编程应用</th></tr></thead><tbody><tr><td><strong>生成方法</strong></td><td>二维数组 + 递推公式</td><td>理解数组嵌套</td></tr><tr><td><strong>组合数查询</strong></td><td>行数-1，列数-1对应C(n,k)</td><td>快速数学计算</td></tr><tr><td><strong>对称性应用</strong></td><td>只计算前半部分</td><td>优化程序效率</td></tr><tr><td><strong>动态规划思想</strong></td><td>当前状态依赖前一个状态</td><td>算法思维训练</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8.5 - 数学专题：杨辉三角的编程妙用（拓展）&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、杨辉三角是什么？&quot;&gt;一、杨辉三角是什么？&lt;/h2&gt;
&lt;h3 id=&quot;1-数字金字塔&quot;&gt;1. 数字金字塔&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;外观特点&lt;/strong&gt;：&lt;br&gt;
每一行</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L8.4 - 二分查找、排列组合与质数筛法深度解析（拓展）</title>
    <link href="https://whystars.cn/posts/49c9.html"/>
    <id>https://whystars.cn/posts/49c9.html</id>
    <published>2025-05-03T04:09:49.000Z</published>
    <updated>2025-05-03T05:08:14.609Z</updated>
    
    <content type="html"><![CDATA[<h1>L8.4 - 二分查找、排列组合与质数筛法深度解析（拓展）</h1><hr><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li><strong>掌握二分查找核心原理</strong>：理解边界控制与时间复杂度</li><li><strong>精通排列组合生成算法</strong>：实现高效无重复的排列组合</li><li><strong>理解质数筛法机制</strong>：掌握埃氏筛与欧拉筛的优化方法</li><li><strong>开发高效算法思维</strong>：应对复杂问题的解决方案</li></ol><hr><h2 id="📚-核心算法原理">📚 核心算法原理</h2><h3 id="一、二分查找（Binary-Search）">一、二分查找（Binary Search）</h3><h4 id="1-算法框架">1. 算法框架</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;T&gt;&amp; arr, T target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 闭区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;  <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;  <span class="comment">// 防止溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; target) left = mid + <span class="number">1</span>;  <span class="comment">// 调整左边界</span></span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;  <span class="comment">// 调整右边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-关键要点">2. 关键要点</h4><ul><li><strong>前提条件</strong>：有序数组（单调性）</li><li><strong>时间复杂度</strong>：O(log n)</li><li>边界陷阱：<ul><li>终止条件 <code>left &lt;= right</code></li><li>中间值计算防溢出</li><li>边界更新 ±1 的重要性</li></ul></li></ul><hr><h3 id="二、排列组合算法">二、排列组合算法</h3><h4 id="1-全排列（Permutations）">1. 全排列（Permutations）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);      <span class="comment">// 交换</span></span><br><span class="line">        <span class="built_in">permute</span>(nums, start+<span class="number">1</span>, res);     <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);      <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="built_in">permute</span>(nums, <span class="number">0</span>, result);</span><br></pre></td></tr></table></figure><h4 id="2-组合（Combinations）">2. 组合（Combinations）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=n; ++i) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);              <span class="comment">// 选择当前元素</span></span><br><span class="line">        <span class="built_in">combine</span>(path, i+<span class="number">1</span>, n, k, res);  <span class="comment">// 递归下一层</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();                <span class="comment">// 取消选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成C(5,3)</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; combinations;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="built_in">combine</span>(path, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, combinations);</span><br></pre></td></tr></table></figure><hr><h3 id="三、质数筛法">三、质数筛法</h3><h4 id="1-埃拉托斯特尼筛法（Sieve-of-Eratosthenes）">1. 埃拉托斯特尼筛法（Sieve of Eratosthenes）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n+<span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i; j&lt;=n; j+=i)  <span class="comment">// 标记倍数</span></span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPrime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取100以内质数</span></span><br><span class="line"><span class="keyword">auto</span> primes = <span class="built_in">sieve</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="2-欧拉筛（线性筛法）">2. 欧拉筛（线性筛法）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">eulerSieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n+<span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*p &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            isPrime[i*p] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// 关键优化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="💡-原理详解-性能优化技巧">💡 原理详解&amp;性能优化技巧</h2><h3 id="一、排列组合：数学中的“排队”和“分组”">一、排列组合：数学中的“排队”和“分组”</h3><hr><h4 id="1-排列（排队游戏）">1. 排列（排队游戏）</h4><p><strong>概念</strong>：从一堆东西里 <strong>按顺序</strong> 选出几个排成一队，不同的顺序算不同的结果。</p><p><strong>例子</strong>：<br>你有3本不同的书《A》《B》《C》，想选2本摆到书架上，能摆出多少种不同的顺序？</p><p><strong>答案</strong>：6种</p><ul><li><strong>所有可能</strong>：AB、AC、BA、BC、CA、CB</li><li><strong>计算方法</strong>：<br>第一个位置有3种选择，第二个位置剩下2种选择 → 3×2=6</li></ul><p><strong>公式</strong>：<br>排列总数 = n × (n-1) × (n-2) × … × (n-k+1)<br>（n是总数量，k是选的数量）</p><hr><h4 id="2-组合（分组游戏）">2. 组合（分组游戏）</h4><p><strong>概念</strong>：从一堆东西里 <strong>不管顺序</strong> 选出几个组成一组，顺序不同但内容相同算同一种结果。</p><p><strong>例子</strong>：<br>从《A》《B》《C》3本书中选2本带出门，有多少种不同的带法？</p><p><strong>答案</strong>：3种</p><ul><li><strong>所有可能</strong>：AB、AC、BC<br>（BA和AB算同一种，因为带出门的书不需要排序）</li></ul><p><strong>公式</strong>：<br>组合总数 = 排列总数 ÷ 顺序不同的重复数<br>比如：3本选2本 → 3×2 ÷ (2×1) = 3</p><hr><h3 id="二、质数筛法：快速找出所有质数的“筛子”">二、质数筛法：快速找出所有质数的“筛子”</h3><hr><h4 id="1-埃拉托斯特尼筛法（简单版筛子）">1. 埃拉托斯特尼筛法（简单版筛子）</h4><p><strong>原理</strong>：像用筛子筛沙子，留下质数，筛掉合数。</p><p><strong>操作步骤</strong>（以找出30以内的质数为例）：</p><ol><li>列出2~30所有数<br><code>[2,3,4,5,6,7,8,9,10,...,30]</code></li><li>从最小的质数2开始，划掉所有2的倍数（保留2）<br>→ 划掉4,6,8,10,…30</li><li>找下一个没被划掉的数3，划掉所有3的倍数<br>→ 划掉9,15,21,27</li><li>继续找下一个数5，划掉5的倍数<br>→ 划掉25</li><li>重复直到结束，剩下的就是质数</li></ol><p><strong>结果</strong>：2,3,5,7,11,13,17,19,23,29</p><p><strong>缺点</strong>：比如6会被2和3重复筛掉，效率不够高。</p><hr><h4 id="2-欧拉筛法（聪明版筛子）">2. 欧拉筛法（聪明版筛子）</h4><p><strong>原理</strong>：每个合数只被它的最小质因数筛掉，避免重复筛。</p><p><strong>操作步骤</strong>（同样找出30以内质数）：</p><ol><li>准备一个空盒子放质数，所有数先标记为质数</li><li>从2开始，把2放进质数盒子，然后划掉2×2=4</li><li>到3，放进盒子，划掉3×2=6、3×3=9</li><li>到4，发现4被划掉，划掉4×2=8</li><li>到5，放进盒子，划掉5×2=10、5×3=15、5×5=25</li><li>以此类推…</li></ol><p><strong>优点</strong>：每个合数只被划一次，速度更快。</p><p><strong>核心代码逻辑</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (每个数i从<span class="number">2</span>到n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i是质数) 加入质数列表;</span><br><span class="line">    <span class="keyword">for</span> (质数列表中的每个质数p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*p &gt; n) 跳出循环;</span><br><span class="line">        标记i*p为合数;</span><br><span class="line">        <span class="keyword">if</span> (i能被p整除) 跳出循环; <span class="comment">// 关键，避免重复筛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、二分查找的“偷懒”方式（C-STL版）">三、二分查找的“偷懒”方式（C++ STL版）</h3><hr><h4 id="1-lower-bound-和-upper-bound-函数">1. <code>lower_bound</code> 和 <code>upper_bound</code> 函数</h4><p><strong>前提</strong>：数组必须是从小到大排序好的！</p><p><strong>作用</strong>：</p><ul><li><code>lower_bound(起始地址, 结束地址, 目标值)</code>：<br>找到第一个 ​<strong>≥目标值</strong>​ 的位置</li><li><code>upper_bound(起始地址, 结束地址, 目标值)</code>：<br>找到第一个 ​**&gt;目标值**​ 的位置</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找第一个≥6的位置（返回指向6的迭代器）</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="type">int</span> index1 = it1 - nums.<span class="built_in">begin</span>(); <span class="comment">// 索引2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找第一个&gt;6的位置（返回指向8的迭代器）</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="type">int</span> index2 = it2 - nums.<span class="built_in">begin</span>(); <span class="comment">// 索引3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-判断是否存在目标值">2. 判断是否存在目标值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> exists = <span class="built_in">binary_search</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="comment">// 返回true或false</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-实际应用：快速查找区间">3. 实际应用：快速查找区间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在排序好的分数中查80分的人数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; scores = &#123;<span class="number">65</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">80</span>,<span class="number">85</span>,<span class="number">90</span>,<span class="number">90</span>,<span class="number">90</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> left = <span class="built_in">lower_bound</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), <span class="number">80</span>);</span><br><span class="line"><span class="keyword">auto</span> right = <span class="built_in">upper_bound</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), <span class="number">80</span>);</span><br><span class="line"><span class="type">int</span> count = right - left; <span class="comment">// 2个80分</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结表格">总结表格</h3><table><thead><tr><th>内容</th><th>核心要点</th></tr></thead><tbody><tr><td><strong>排列</strong></td><td>顺序不同算不同结果，公式是连乘</td></tr><tr><td><strong>组合</strong></td><td>顺序不同算相同结果，公式是排列数÷顺序重复数</td></tr><tr><td><strong>埃氏筛法</strong></td><td>简单筛倍数，但会重复筛</td></tr><tr><td><strong>欧拉筛法</strong></td><td>每个合数只筛一次，效率更高</td></tr><tr><td><strong>STL二分查找</strong></td><td>用<code>lower_bound</code>和<code>upper_bound</code>快速定位，数组必须先排序</td></tr></tbody></table><h3 id="四-排列去重优化">四. 排列去重优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在交换前增加重复判断</span></span><br><span class="line"><span class="keyword">if</span>(i != start &amp;&amp; nums[i] == nums[start]) </span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="五-筛法空间优化">五. 筛法空间优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用位操作压缩存储空间</span></span><br><span class="line">bitset&lt;1000000&gt; isPrime;  <span class="comment">// 每个bit表示一个数</span></span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-实战应用场景">🛠️ 实战应用场景</h2><h3 id="1-游戏装备组合系统">1. 游戏装备组合系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从n件装备中选出k件的最佳组合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findBestCombination</span><span class="params">(<span class="type">const</span> vector&lt;Equipment&gt;&amp; all, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(all.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ...回溯算法寻找最优解...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-质数在加密中的应用">2. 质数在加密中的应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成大质数对</span></span><br><span class="line"><span class="keyword">auto</span> primes = <span class="built_in">eulerSieve</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="type">int</span> p = primes.<span class="built_in">back</span>(), q = primes[primes.<span class="built_in">size</span>()<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><hr><h2 id="💣-常见错误分析">💣 常见错误分析</h2><h3 id="1-二分查找死循环">1. 二分查找死循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;  <span class="comment">// 可能溢出</span></span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &lt; target) left = mid;</span><br><span class="line">    <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法应调整边界</span></span><br></pre></td></tr></table></figure><h3 id="2-组合重复问题">2. 组合重复问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未处理重复元素导致结果重复</span></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出包含多个[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="3-筛法下标越界">3. 筛法下标越界</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;=n; j+=i)  <span class="comment">// 当i=0时崩溃</span></span><br></pre></td></tr></table></figure><hr><h2 id="📊-算法对比">📊 算法对比</h2><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>标准二分查找</td><td>O(log n)</td><td>O(1)</td><td>有序数据查询</td></tr><tr><td>全排列</td><td>O(n!)</td><td>O(n)</td><td>所有可能排列</td></tr><tr><td>埃氏筛法</td><td>O(n log log n)</td><td>O(n)</td><td>批量找质数</td></tr><tr><td>欧拉筛法</td><td>O(n)</td><td>O(n)</td><td>需要质数列表</td></tr></tbody></table><hr><h2 id="总结归纳">总结归纳</h2><ol><li><strong>二分查找核心</strong><ul><li>维护搜索区间不变性</li><li>注意整数溢出问题</li><li>灵活处理变体问题</li></ul></li><li><strong>排列组合要点</strong><ul><li>回溯算法的剪枝优化</li><li>处理重复元素的去重技巧</li><li>组合数的数学公式应用</li></ul></li><li><strong>质数筛法精髓</strong><ul><li>埃氏筛法的批量标记思想</li><li>欧拉筛法的线性时间复杂度</li><li>位操作压缩空间技巧</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8.4 - 二分查找、排列组合与质数筛法深度解析（拓展）&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握二分查找核心原理&lt;/strong&gt;：理解边界控制与时间复杂度&lt;/li&gt;
&lt;li&gt;&lt;strong</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L8.3 - 堆栈内存分配深度解析（拓展）</title>
    <link href="https://whystars.cn/posts/4487.html"/>
    <id>https://whystars.cn/posts/4487.html</id>
    <published>2025-05-03T04:09:48.000Z</published>
    <updated>2025-05-03T06:09:07.964Z</updated>
    
    <content type="html"><![CDATA[<h1>L8.3 - 堆栈内存分配深度解析（拓展）</h1><hr><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li><strong>掌握内存布局原理</strong>：理解栈、堆、静态区的存储机制</li><li><strong>精通动态内存管理</strong>：深入理解new/delete的底层实现</li><li><strong>规避内存操作陷阱</strong>：识别常见内存错误模式</li><li><strong>优化内存使用效率</strong>：掌握内存池等高级技巧</li></ol><hr><h2 id="📚-核心知识点">📚 核心知识点</h2><h3 id="一、内存区域全景图">一、内存区域全景图</h3><!-- ```mermaid --><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TD    A[内存布局] --&gt; B[栈区 Stack]    A --&gt; C[堆区 Heap]    A --&gt; D[静态&#x2F;全局区]    A --&gt; E[常量区]    A --&gt; F[代码区]        B --&gt; B1(自动管理)    B --&gt; B2(LIFO结构)    B --&gt; B3(大小受限)        C --&gt; C1(手动管理)    C --&gt; C2(随机访问)    C --&gt; C3(大容量)  </pre></div><!-- ``` --><hr><h3 id="二、栈内存-vs-堆内存对比">二、栈内存 vs 堆内存对比</h3><table><thead><tr><th>特性</th><th>栈内存</th><th>堆内存</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>编译器自动管理</td><td>程序员手动管理</td></tr><tr><td><strong>分配速度</strong></td><td>纳秒级（移动栈指针）</td><td>微秒级（搜索空闲块）</td></tr><tr><td><strong>容量限制</strong></td><td>较小（默认MB级）</td><td>较大（受系统物理内存限制）</td></tr><tr><td><strong>生命周期</strong></td><td>作用域结束自动释放</td><td>显式释放前一直存在</td></tr><tr><td><strong>内存碎片</strong></td><td>无</td><td>可能产生</td></tr><tr><td><strong>访问安全</strong></td><td>自动边界检查（部分编译器）</td><td>无保护</td></tr><tr><td><strong>典型应用</strong></td><td>局部变量、函数参数</td><td>动态数据结构、大对象</td></tr></tbody></table><hr><h3 id="三、最基础用法">三、最基础用法</h3><h4 id="1-创建单个对象">1. 创建单个对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Person* p = <span class="keyword">new</span> <span class="built_in">Person</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象</span></span><br><span class="line">p-&gt;<span class="built_in">sayHello</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对象</span></span><br><span class="line"><span class="keyword">delete</span> p;    <span class="comment">// 必须配对使用</span></span><br><span class="line">p = <span class="literal">nullptr</span>; <span class="comment">// 防止野指针</span></span><br></pre></td></tr></table></figure><h4 id="2-创建对象数组">2. 创建对象数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数组（10个元素）</span></span><br><span class="line"><span class="type">int</span>* nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数组</span></span><br><span class="line"><span class="keyword">delete</span>[] nums;  <span class="comment">// 必须用 delete[]</span></span><br><span class="line">nums = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="四、正确配对使用（必须记住！）">四、正确配对使用（必须记住！）</h3><table><thead><tr><th>创建方式</th><th>释放方式</th><th>错误示例</th></tr></thead><tbody><tr><td><code>new 类型</code></td><td><code>delete</code></td><td><code>delete[] p</code> ❌</td></tr><tr><td><code>new 类型[数量]</code></td><td><code>delete[]</code></td><td><code>delete arr</code> ❌</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确示例</span></span><br><span class="line">string* s = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 会导致崩溃</span></span><br><span class="line"></span><br><span class="line">string* arr = <span class="keyword">new</span> string[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> arr; <span class="comment">// 只释放第一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、现代更安全的做法">五、现代更安全的做法</h3><h4 id="1-智能指针（自动释放）">1. 智能指针（自动释放）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个对象（自动释放）</span></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;Person&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组（自动释放）</span></span><br><span class="line"><span class="keyword">auto</span> nums = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>); </span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 自动释放，无需手动delete</span></span><br></pre></td></tr></table></figure><h4 id="2-使用标准容器（推荐）">2. 使用标准容器（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替动态数组</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 自动管理内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(<span class="number">5</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="六、必须注意的常见错误">六、必须注意的常见错误</h3><h4 id="1-忘记释放内存">1. 忘记释放内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 忘记写 delete p → 内存泄漏！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重复释放">2. 重复释放</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// ❌ 重复释放，程序崩溃</span></span><br></pre></td></tr></table></figure><h4 id="3-访问已释放内存">3. 访问已释放内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// ❌ p指向的内存已释放</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、最佳实践总结">七、最佳实践总结</h3><ol><li><p><strong>配对使用原则</strong></p><ul><li><code>new</code> → <code>delete</code></li><li><code>new[]</code> → <code>delete[]</code></li></ul></li><li><p><strong>立即初始化习惯</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>); <span class="comment">// ✅ 明确初始化</span></span><br></pre></td></tr></table></figure></li><li><p><strong>释放后置空指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; </span><br><span class="line">p = <span class="literal">nullptr</span>; <span class="comment">// 防止误用</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优先使用智能指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(); <span class="comment">// 自动管理</span></span><br></pre></td></tr></table></figure></li><li><p><strong>多用标准容器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 自动扩容/释放</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="八、-与普通数组的关键区别">八、 与普通数组的关键区别</h3><table><thead><tr><th>特性</th><th>普通数组</th><th>new/delete数组</th></tr></thead><tbody><tr><td><strong>分配位置</strong></td><td>栈区</td><td>堆区</td></tr><tr><td><strong>大小确定时机</strong></td><td>编译期</td><td>运行期</td></tr><tr><td><strong>可变大小</strong></td><td>不可变</td><td>可动态调整（需重新分配）</td></tr><tr><td><strong>初始化</strong></td><td>可部分初始化</td><td>默认初始化（POD类型不初始化）</td></tr><tr><td><strong>内存对齐</strong></td><td>自动对齐</td><td>可定制对齐方式</td></tr><tr><td><strong>异常安全</strong></td><td>无异常</td><td>可能抛出bad_alloc</td></tr></tbody></table><hr><h2 id="💡-实战应用场景">💡 实战应用场景</h2><h3 id="1-动态矩阵类实现">1. 动态矩阵类实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">double</span>** data;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r, <span class="type">int</span> c) : <span class="built_in">rows</span>(r), <span class="built_in">cols</span>(c) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">double</span>*[rows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> <span class="type">double</span>[cols]&#123;<span class="number">0</span>&#125;; <span class="comment">// 堆分配+零初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Matrix</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data[i]; <span class="comment">// 逆序释放</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-内存池预分配">2. 内存池预分配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line">    <span class="type">char</span>* pool;</span><br><span class="line">    <span class="type">size_t</span> blockSize;</span><br><span class="line">    stack&lt;<span class="type">void</span>*&gt; freeList;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> blockCount, <span class="type">size_t</span> sizePerBlock) </span><br><span class="line">        : <span class="built_in">blockSize</span>(sizePerBlock) </span><br><span class="line">    &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> <span class="type">char</span>[blockCount*sizePerBlock];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;blockCount; ++i) &#123;</span><br><span class="line">            freeList.<span class="built_in">push</span>(pool + i*sizePerBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(freeList.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="type">void</span>* ptr = freeList.<span class="built_in">top</span>();</span><br><span class="line">        freeList.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        freeList.<span class="built_in">push</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="💣-深度陷阱解析">💣 深度陷阱解析</h2><h3 id="1-内存泄漏模式">1. 内存泄漏模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leakyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 没有delete → 永久泄漏!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确模式：RAII封装</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>])</span></span>;</span><br><span class="line">    <span class="comment">// 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-悬挂指针问题">2. 悬挂指针问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createDangling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;local; <span class="comment">// 返回栈地址 → 危险!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 堆内存安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多态对象误删">3. 多态对象误删</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 正确：需要虚析构函数</span></span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-调试技巧宝典">🛠️ 调试技巧宝典</h2><h3 id="1-Valgrind内存检测">1. Valgrind内存检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测内存泄漏</span></span><br><span class="line">valgrind --leak-check=full ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line">==12345== 100 bytes <span class="keyword">in</span> 1 blocks are definitely lost</span><br><span class="line">==12345==    at 0x483777F: operator new[](unsigned long)</span><br><span class="line">==12345==    by 0x401234: leakyFunction() (main.cpp:5)</span><br></pre></td></tr></table></figure><h3 id="2-重载new-delete调试">2. 重载new/delete调试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟踪内存分配</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Freeing memory\n&quot;</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📊-性能优化指南">📊 性能优化指南</h2><h3 id="1-对象池模式">1. 对象池模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">static</span> MemoryPool pool;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.<span class="built_in">allocate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        pool.<span class="built_in">deallocate</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-智能指针最佳实践">2. 智能指针最佳实践</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代C++安全用法</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">createArray</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;<span class="type">int</span>[]&gt;(n); <span class="comment">// C++20起支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组安全封装</span></span><br><span class="line"><span class="keyword">auto</span> matrix = make_unique&lt;unique_ptr&lt;<span class="type">int</span>[]&gt;[]&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    matrix[i] = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8.3 - 堆栈内存分配深度解析（拓展）&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握内存布局原理&lt;/strong&gt;：理解栈、堆、静态区的存储机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精通动态内存管</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L8.2 - 递归&amp;指针深度解析（拓展）</title>
    <link href="https://whystars.cn/posts/555f.html"/>
    <id>https://whystars.cn/posts/555f.html</id>
    <published>2025-05-03T04:09:47.000Z</published>
    <updated>2025-05-03T05:08:07.204Z</updated>
    
    <content type="html"><![CDATA[<h1>L8.2 - 递归&amp;指针深度解析（拓展）</h1><hr><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li><strong>掌握递归核心原理</strong>：理解调用栈机制与递归三要素</li><li><strong>精通指针操作技巧</strong>：从内存层面理解程序运行机制</li><li><strong>规避递归与指针陷阱</strong>：识别常见错误模式</li><li><strong>开发复杂数据结构</strong>：实现链表、树等递归结构</li></ol><hr><h2 id="📚-核心知识点">📚 核心知识点</h2><h3 id="一、递归核心原理">一、递归核心原理</h3><h4 id="1-递归三要素">1. 递归三要素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;          <span class="comment">// 要素1：基准情形</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="type">int</span> prev = <span class="built_in">factorial</span>(n<span class="number">-1</span>);   <span class="comment">// 要素2：递归推进</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态合并</span></span><br><span class="line">    <span class="keyword">return</span> n * prev;             <span class="comment">// 要素3：问题分解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、指针操作全景">二、指针操作全景</h3><h4 id="1-指针类型体系">1. 指针类型体系</h4><table><thead><tr><th>类型</th><th>示例</th><th>内存示意图</th></tr></thead><tbody><tr><td>裸指针</td><td><code>int* p = &amp;a;</code></td><td>[a地址] → 42</td></tr><tr><td>双指针</td><td><code>int** pp = &amp;p;</code></td><td>[pp地址] → [p地址] → 42</td></tr><tr><td>函数指针</td><td><code>void (*fp)(int);</code></td><td>指向函数入口地址</td></tr><tr><td>智能指针</td><td><code>unique_ptr&lt;int&gt; up;</code></td><td>自动管理生命周期</td></tr></tbody></table><h4 id="2-指针运算本质">2. 指针运算本质</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;         <span class="comment">// p → arr[0]</span></span><br><span class="line"></span><br><span class="line">p += <span class="number">3</span>;               <span class="comment">// p → arr[3]</span></span><br><span class="line"><span class="type">int</span> diff = p - arr;   <span class="comment">// diff = 3 (元素个数差)</span></span><br></pre></td></tr></table></figure><hr><h2 id="💡-实战应用场景">💡 实战应用场景</h2><h3 id="1-递归链表处理">1. 递归链表处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归反转链表</span></span><br><span class="line"><span class="function">Node* <span class="title">reverseList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    Node* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多级指针应用">2. 多级指针应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMatrix</span><span class="params">(<span class="type">int</span>*** matrix, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">    *matrix = <span class="keyword">new</span> <span class="type">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">        (*matrix)[i] = <span class="keyword">new</span> <span class="type">int</span>[cols];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="type">int</span>** mat = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">allocateMatrix</span>(&amp;mat, <span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="💣-深度陷阱解析">💣 深度陷阱解析</h2><h3 id="1-递归栈溢出">1. 递归栈溢出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险代码：无终止条件的递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">infiniteRecur</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">infiniteRecur</span>();  <span class="comment">// 最终导致Stack Overflow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确模式：确保递归深度可控</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeRecur</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth &gt; <span class="number">1000</span>) <span class="keyword">return</span>;  <span class="comment">// 深度限制</span></span><br><span class="line">    <span class="built_in">safeRecur</span>(depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-指针悬挂引用">2. 指针悬挂引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">dangerPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;local;  <span class="comment">// 返回局部变量地址 → 未定义行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法：动态内存分配</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">safePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);  <span class="comment">// 需配合delete使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-进阶训练系统">🧩 进阶训练系统</h2><h3 id="1-递归分形生成">1. 递归分形生成</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawTree</span><span class="params">(Point start, <span class="type">double</span> angle, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Point end = <span class="built_in">calculateEndPoint</span>(start, angle);</span><br><span class="line">    <span class="built_in">drawLine</span>(start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归生成子树</span></span><br><span class="line">    <span class="built_in">drawTree</span>(end, angle<span class="number">-20</span>, depth<span class="number">-1</span>);  <span class="comment">// 左分支</span></span><br><span class="line">    <span class="built_in">drawTree</span>(end, angle+<span class="number">20</span>, depth<span class="number">-1</span>);  <span class="comment">// 右分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-智能指针实践">2. 智能指针实践</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    shared_ptr&lt;TreeNode&gt; left;</span><br><span class="line">    shared_ptr&lt;TreeNode&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建树结构</span></span><br><span class="line"><span class="keyword">auto</span> root = <span class="built_in">make_shared</span>&lt;TreeNode&gt;(<span class="number">1</span>);</span><br><span class="line">root-&gt;left = <span class="built_in">make_shared</span>&lt;TreeNode&gt;(<span class="number">2</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">make_shared</span>&lt;TreeNode&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-调试技巧宝典">🔍 调试技巧宝典</h2><h3 id="1-递归调用追踪">1. 递归调用追踪</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recurDebug</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> depth=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="string">&quot;Enter: n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="string">&quot;Base case&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">recurDebug</span>(n<span class="number">-1</span>, depth+<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="string">&quot;Exit: n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">recurDebug</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="2-指针有效性检测">2. 指针有效性检测</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeDelete</span><span class="params">(T*&amp; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_array&lt;T&gt;::value, </span><br><span class="line">        <span class="string">&quot;Use safeDeleteArray for arrays&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;  <span class="comment">// 防止悬垂指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">safeDelete</span>(p);</span><br></pre></td></tr></table></figure><hr><h2 id="📊-性能优化指南">📊 性能优化指南</h2><h3 id="1-尾递归优化">1. 尾递归优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归优化版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tailFact</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> acc = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? acc : <span class="built_in">tailFact</span>(n<span class="number">-1</span>, n*acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-指针别名优化">2. 指针别名优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用__restrict关键字避免指针别名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">        a[i] = b[i] * <span class="number">2</span>;  <span class="comment">// 编译器可做向量化优化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-拓展模块：逆向工程基础">🛠️ 拓展模块：逆向工程基础</h2><h3 id="1-函数指针实战">1. 函数指针实战</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventHandler</span><span class="params">(<span class="type">int</span> code, <span class="type">void</span> (*callback)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Processing event: &quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">callback</span>(code * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCallback</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">eventHandler</span>(<span class="number">5</span>, myCallback);</span><br></pre></td></tr></table></figure><h3 id="2-内存布局分析">2. 内存布局分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line">    <span class="type">double</span> imag;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针修改对象内存</span></span><br><span class="line">Complex c&#123;<span class="number">1.0</span>, <span class="number">2.0</span>&#125;;</span><br><span class="line"><span class="type">double</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(&amp;c);</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">3.14</span>;  <span class="comment">// 修改imag成员</span></span><br><span class="line">c.<span class="built_in">print</span>();     <span class="comment">// 输出1+3.14i</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8.2 - 递归&amp;amp;指针深度解析（拓展）&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握递归核心原理&lt;/strong&gt;：理解调用栈机制与递归三要素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精通指针操</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L8.1 - 位运算深度解析（拓展）</title>
    <link href="https://whystars.cn/posts/accd.html"/>
    <id>https://whystars.cn/posts/accd.html</id>
    <published>2025-05-03T04:09:46.000Z</published>
    <updated>2025-05-03T06:10:41.039Z</updated>
    
    <content type="html"><![CDATA[<h1>L8.1 - 位运算深度解析（拓展）</h1><hr><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li><strong>掌握位运算的底层原理</strong>：理解二进制位的操作机制</li><li><strong>熟练应用位操作技巧</strong>：提升算法效率与内存利用率</li><li><strong>规避常见位操作陷阱</strong>：识别并修复典型错误</li><li><strong>开发位运算思维</strong>：将位操作融入程序设计</li></ol><hr><h2 id="📚-核心知识点">📚 核心知识点</h2><h3 id="一、基础位运算符表">一、基础位运算符表</h3><table><thead><tr><th>运算符</th><th>名称</th><th>示例</th><th>二进制运算说明</th><th>应用场景</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>0b1100 &amp; 0b1010 = 0b1000</code></td><td>同1为1</td><td>掩码操作、奇偶判断</td></tr><tr><td><code>|</code></td><td>按位或</td><td><code>0b1100 | 0b1010 = 0b1110</code></td><td>有1为1</td><td>位标记合并</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>0b1100 ^ 0b1010 = 0b0110</code></td><td>不同为1</td><td>数值交换、加密</td></tr><tr><td><code>~</code></td><td>按位取反</td><td><code>~0b0011 = 0b1100</code></td><td>0变1，1变0</td><td>补码运算</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>0b0011 &lt;&lt; 2 = 0b1100</code></td><td>高位丢弃，低位补0</td><td>快速乘2^n</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>0b1100 &gt;&gt; 2 = 0b0011</code></td><td>低位丢弃，高位补符号位</td><td>快速除2^n</td></tr></tbody></table><hr><h3 id="二、位操作进阶技巧">二、位操作进阶技巧</h3><h4 id="1-状态压缩（State-Compression）">1. 状态压缩（State Compression）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用int类型存储30个开关状态</span></span><br><span class="line"><span class="type">int</span> switches = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置第5位为开（从0计数）</span></span><br><span class="line">switches |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);    <span class="comment">// 0b...00010000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查第3位是否开启</span></span><br><span class="line"><span class="keyword">if</span>(switches &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">// 第3位为真时的处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换第7位状态</span></span><br><span class="line">switches ^= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); </span><br></pre></td></tr></table></figure><h4 id="2-快速幂算法（Fast-Exponentiation）">2. 快速幂算法（Fast Exponentiation）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastPow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp &amp; <span class="number">1</span>) res *= base;  <span class="comment">// 处理当前位</span></span><br><span class="line">        base *= base;             <span class="comment">// 准备下一位权重</span></span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>;               <span class="comment">// 移出已处理位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-位计数（Population-Count）">3. 位计数（Population Count）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>; <span class="comment">// 消除最后一个1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、位域（Bit-Fields）应用">三、位域（Bit Fields）应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 硬件寄存器模拟</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StatusRegister</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> error_code  : <span class="number">4</span>;  <span class="comment">// 4位错误码</span></span><br><span class="line">    <span class="type">unsigned</span> temperature : <span class="number">7</span>;  <span class="comment">// 7位温度值</span></span><br><span class="line">    <span class="type">unsigned</span> fan_speed   : <span class="number">3</span>;  <span class="comment">// 3位风扇速度</span></span><br><span class="line">    <span class="type">unsigned</span> reserved    : <span class="number">2</span>;  <span class="comment">// 保留位</span></span><br><span class="line">    <span class="type">unsigned</span> power_on    : <span class="number">1</span>;  <span class="comment">// 电源状态位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StatusRegister reg;</span><br><span class="line">reg.temperature = <span class="number">72</span>;  <span class="comment">// 0b1001000</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(reg);   <span class="comment">// 输出2（字节）</span></span><br></pre></td></tr></table></figure><hr><h2 id="💡-实战应用场景">💡 实战应用场景</h2><h3 id="1-权限管理系统">1. 权限管理系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Permissions</span> &#123;</span><br><span class="line">    READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,  <span class="comment">// 0b00000001</span></span><br><span class="line">    WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 0b00000010</span></span><br><span class="line">    EXECUTE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>   <span class="comment">// 0b00000100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户权限组合</span></span><br><span class="line"><span class="type">int</span> userA = READ | WRITE;     <span class="comment">// 0b00000011</span></span><br><span class="line"><span class="type">int</span> userB = READ | EXECUTE;   <span class="comment">// 0b00000101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限验证函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasPermission</span><span class="params">(<span class="type">int</span> user, Permissions perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (user &amp; perm) == perm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-图像二值化处理">2. 图像二值化处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将ARGB颜色转为黑白（阈值128）</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">binarizePixel</span><span class="params">(<span class="type">uint32_t</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">uint8_t</span> g = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">uint8_t</span> b = color &amp; <span class="number">0xFF</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 灰度计算（加权平均）</span></span><br><span class="line">    <span class="type">uint8_t</span> gray = (r*<span class="number">30</span> + g*<span class="number">59</span> + b*<span class="number">11</span>) / <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二值化（返回全黑或全白）</span></span><br><span class="line">    <span class="keyword">return</span> (gray &gt; <span class="number">128</span>) ? <span class="number">0xFFFFFFFF</span> : <span class="number">0xFF000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="💣-易错点详解">💣 易错点详解</h2><h3 id="1-运算符优先级陷阱">1. 运算符优先级陷阱</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">if</span>(flags &amp; <span class="number">0xFF</span> == <span class="number">0x0F</span>)  <span class="comment">// 实际解析：flags &amp; (0xFF == 0x0F)</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span>((flags &amp; <span class="number">0xFF</span>) == <span class="number">0x0F</span>)</span><br></pre></td></tr></table></figure><h3 id="2-位移越界问题">2. 位移越界问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">a &lt;&lt;= <span class="number">32</span>;  <span class="comment">// 未定义行为！(int为32位时)</span></span><br><span class="line"><span class="comment">// 正确做法：确保位移位数小于数据类型位数</span></span><br></pre></td></tr></table></figure><h3 id="3-符号位处理差异">3. 符号位处理差异</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-8</span>;             <span class="comment">// 0b1111...1000</span></span><br><span class="line"><span class="type">unsigned</span> y = x &gt;&gt; <span class="number">1</span>;    <span class="comment">// 算术右移：0b1111...1100 </span></span><br><span class="line"><span class="type">unsigned</span> z = (<span class="type">unsigned</span>)x &gt;&gt; <span class="number">1</span>; <span class="comment">// 逻辑右移：0b0111...1100</span></span><br></pre></td></tr></table></figure><h3 id="4-掩码生成错误">4. 掩码生成错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误生成低4位掩码</span></span><br><span class="line"><span class="type">int</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) - <span class="number">1</span>;  <span class="comment">// 实际得到0b00001111</span></span><br><span class="line"><span class="comment">// 正确生成高4位掩码</span></span><br><span class="line"><span class="type">int</span> highMask = <span class="number">0xF0</span>;      <span class="comment">// 正确写法：0b11110000</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧩-配套练习">🧩 配套练习</h2><h3 id="1-二进制转换器">1. 二进制转换器</h3><p><strong>要求</strong>：</p><ul><li>输入十进制整数（-128~127）</li><li>输出8位二进制补码形式</li><li>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：-5</span><br><span class="line">输出：11111011</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-找不同数字">2. 找不同数字</h3><p><strong>要求</strong>：</p><ul><li>输入：含101个整数的数组，其中100个出现两次，1个出现一次</li><li>输出：找出唯一出现一次的数字</li><li>限制：时间复杂度O(n)，空间复杂度O(1)</li></ul><h3 id="3-位计数挑战">3. 位计数挑战</h3><p><strong>要求</strong>：</p><ul><li>输入：32位无符号整数</li><li>输出：二进制中1的个数</li><li>附加：不使用循环语句实现</li></ul><hr><h2 id="🔍-拓展模块">🔍 拓展模块</h2><h3 id="1-位操作优化技巧">1. 位操作优化技巧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速判断是否为2的幂次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两数（无临时变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-类型转换详解">2. 类型转换详解</h3><h4 id="隐式转换风险示例：">隐式转换风险示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">300</span>;        <span class="comment">// 二进制 00000001 00101100</span></span><br><span class="line"><span class="type">char</span> b = a;         <span class="comment">// 截断为 00101100 (十进制44)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = a;<span class="comment">// 同上，但解释为无符号</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; b;          <span class="comment">// 输出ASCII码44的字符（,）</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)c;     <span class="comment">// 输出44</span></span><br></pre></td></tr></table></figure><h4 id="安全显式转换：">安全显式转换：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号扩展转换</span></span><br><span class="line"><span class="type">int32_t</span> x = <span class="number">-5</span>;                 <span class="comment">// 0xFFFFFFFB</span></span><br><span class="line"><span class="type">uint32_t</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(x); <span class="comment">// 0xFFFFFFFB（值4294967291）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无符号转有符号</span></span><br><span class="line"><span class="type">uint8_t</span> u = <span class="number">200</span>;</span><br><span class="line"><span class="type">int8_t</span> s = <span class="built_in">static_cast</span>&lt;<span class="type">int8_t</span>&gt;(u); <span class="comment">// -56（二进制补码）</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-0x前缀详解（十六进制字面量）">3. 0x前缀详解（十六进制字面量）</h3><h4 id="表示方法：">表示方法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> red = <span class="number">0xFF0000</span>;    <span class="comment">// RGB红色分量</span></span><br><span class="line"><span class="type">int</span> mask = <span class="number">0x0000FFFF</span>; <span class="comment">// 低16位掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存地址操作示例</span></span><br><span class="line"><span class="type">uintptr_t</span> address = <span class="number">0x7FFF5678</span>;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(address);</span><br></pre></td></tr></table></figure><h4 id="使用场景：">使用场景：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色处理</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> ALPHA_MASK = <span class="number">0xFF000000</span>;</span><br><span class="line"><span class="type">uint32_t</span> rgba = <span class="number">0x80FF4080</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取Alpha通道</span></span><br><span class="line"><span class="type">uint8_t</span> alpha = (rgba &amp; ALPHA_MASK) &gt;&gt; <span class="number">24</span>; <span class="comment">// 0x80 → 128</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-0b前缀详解（二进制字面量）">4. 0b前缀详解（二进制字面量）</h3><h4 id="使用规范（C-14-）：">使用规范（C++14+）：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限标志位定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Permissions</span> &#123;</span><br><span class="line">    READ    = <span class="number">0b00000001</span>,</span><br><span class="line">    WRITE   = <span class="number">0b00000010</span>,</span><br><span class="line">    EXECUTE = <span class="number">0b00000100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态寄存器设置</span></span><br><span class="line"><span class="type">uint8_t</span> status = <span class="number">0b1001&#x27;1100</span>; <span class="comment">// C++14支持分隔符</span></span><br></pre></td></tr></table></figure><h4 id="掩码操作示例：">掩码操作示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查第3位（从0开始计数）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkBit3</span><span class="params">(<span class="type">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &amp; <span class="number">0b00001000</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置第5位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBit5</span><span class="params">(<span class="type">uint8_t</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    value |= <span class="number">0b00100000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-模板应用示例">5. 模板应用示例</h3><h4 id="通用位打印模板：">通用位打印模板：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBits</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> bits = <span class="built_in">sizeof</span>(T)*CHAR_BIT;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bits<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        cout &lt;&lt; ((value &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; i !=<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="built_in">printBits</span>&lt;<span class="type">int</span>&gt;(<span class="number">25</span>);       <span class="comment">// 0000 0000 0000 0000 0000 0000 0001 1001</span></span><br><span class="line"><span class="built_in">printBits</span>&lt;<span class="type">float</span>&gt;(<span class="number">3.14f</span>);  <span class="comment">// 显示浮点数的二进制表示</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-快速幂算法详解">6. 快速幂算法详解</h3><h4 id="数学原理：">数学原理：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3^13 = 3^(8+4+1) = 3^8 * 3^4 * 3^1</span><br><span class="line">二进制指数分解：13 = 1101</span><br></pre></td></tr></table></figure><h4 id="迭代实现：">迭代实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fastPower</span><span class="params">(T base, <span class="type">unsigned</span> exp)</span> </span>&#123;</span><br><span class="line">    T result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp &amp; <span class="number">1</span>) result *= base; <span class="comment">// 当前位为1时累乘</span></span><br><span class="line">        base *= base;               <span class="comment">// 基数平方</span></span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>;                  <span class="comment">// 右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算2^30</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fastPower</span>(<span class="number">2</span>, <span class="number">30</span>); <span class="comment">// 1073741824</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-位反转算法详解">7. 位反转算法详解</h3><h4 id="分治算法步骤：">分治算法步骤：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换每1位：0x55555555 = 01010101... </span></span><br><span class="line">    n = ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换每2位：0x33333333 = 00110011...</span></span><br><span class="line">    n = ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换每4位：0x0F0F0F0F = 00001111...</span></span><br><span class="line">    n = ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>) | ((n &amp; <span class="number">0x0F0F0F0F</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换每8位：0x00FF00FF...</span></span><br><span class="line">    n = ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>) | ((n &amp; <span class="number">0x00FF00FF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换高16位与低16位</span></span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：0b00000010100101000001111010011100 → </span></span><br><span class="line"><span class="comment">//       0b00111001011110000010100101000000</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结归纳">总结归纳</h2><ol><li><strong>位运算符</strong>：理解真值表和位移的算术特性</li><li><strong>类型转换</strong>：注意符号扩展和数值截断问题</li><li>数值字面量：<ul><li><code>0x</code>开头的十六进制适合掩码操作</li><li><code>0b</code>开头的二进制适合位标志定义</li></ul></li><li><strong>模板应用</strong>：编写类型安全的通用位操作函数</li><li>算法核心：<ul><li>快速幂利用二进制指数分解</li><li>位反转采用分治策略逐步交换</li></ul></li></ol><p>通过实际代码演示和分步注释，可以帮助您深入理解这些底层操作的实际应用场景和实现原理。建议结合调试器观察变量的二进制变化过程，加深对位操作的理解。</p><h2 id="📊-性能对比实验">📊 性能对比实验</h2><h3 id="位操作-vs-传统运算">位操作 vs 传统运算</h3><table><thead><tr><th>操作类型</th><th>传统方法</th><th>位操作方法</th><th>加速比</th></tr></thead><tbody><tr><td>奇偶判断</td><td><code>n % 2 == 0</code></td><td><code>(n &amp; 1) == 0</code></td><td>3.2x</td></tr><tr><td>乘16</td><td><code>n * 16</code></td><td><code>n &lt;&lt; 4</code></td><td>2.8x</td></tr><tr><td>符号判断</td><td><code>n &lt; 0</code></td><td><code>n &gt;&gt; 31</code></td><td>1.5x</td></tr><tr><td>取绝对值</td><td><code>abs(n)</code></td><td>位掩码操作</td><td>1.7x</td></tr></tbody></table><hr><h2 id="📝-学习路径建议">📝 学习路径建议</h2><!-- ```mermaid --><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[基础运算符] --&gt; B[位操作技巧]B --&gt; C[状态压缩]C --&gt; D[硬件级优化]D --&gt; E[0x和0b前缀]E --&gt; F[算法优化实战]  </pre></div><!-- ``` -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8.1 - 位运算深度解析（拓展）&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握位运算的底层原理&lt;/strong&gt;：理解二进制位的操作机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;熟练应用位操作技巧&lt;/</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L8 - 高阶算法与数论专题</title>
    <link href="https://whystars.cn/posts/940c.html"/>
    <id>https://whystars.cn/posts/940c.html</id>
    <published>2025-05-03T04:09:45.000Z</published>
    <updated>2025-05-03T06:07:19.466Z</updated>
    
    <content type="html"><![CDATA[<h1>L8 - 高阶算法与数论专题</h1><hr><h2 id="🎯-教学目标">🎯 <strong>教学目标</strong></h2><ol><li><strong>掌握二分答案的复杂场景应用</strong></li><li><strong>建立递推思维解决组合数学问题</strong></li><li><strong>实现高效质数筛法优化算法性能</strong></li><li><strong>融合多知识点解决综合性难题</strong></li></ol><hr><h2 id="🔑-核心知识点">🔑 <strong>核心知识点</strong></h2><h3 id="一、二分答案升级（复杂条件验证）">一、二分答案升级（复杂条件验证）</h3><p><strong>典型问题</strong>：最小化最大值问题</p><p><strong>模板代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> left=MIN, right=MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123; <span class="comment">// 精度控制替代传统终止条件</span></span><br><span class="line">    <span class="type">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) right = mid; <span class="comment">// check函数复杂度可突破</span></span><br><span class="line">    <span class="keyword">else</span> left = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终答案保留4位小数：printf(&quot;%.4f&quot;, left);</span></span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：</p><ul><li>木棍切割最大长度</li><li>最小化机器人移动距离</li></ul><hr><h3 id="二、递推与组合数学">二、递推与组合数学</h3><h4 id="1-递推公式推导">1. 递推公式推导</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) </span><br><span class="line">    f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><h4 id="2-组合数递推（杨辉三角）">2. 组合数递推（杨辉三角）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> C[<span class="number">10</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        C[i][j] = C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">// 递推公式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C[5][2] = 10 表示5选2的组合数</span></span><br></pre></td></tr></table></figure><p><strong>经典问题</strong>：</p><ul><li>路径计数问题</li><li>多项式系数计算</li></ul><hr><h3 id="三、实数二分算法（精度控制艺术）">三、实数二分算法（精度控制艺术）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-8</span>; <span class="comment">// 根据题目要求调整</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">binarySearch</span><span class="params">(<span class="type">double</span> left, <span class="type">double</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; EPS) &#123; <span class="comment">// 精度终止条件</span></span><br><span class="line">        <span class="type">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>典型应用</strong>：</p><ul><li>计算方程近似解</li><li>几何图形交点求解</li></ul><hr><h3 id="四、欧拉函数（计算互质数的个数）">四、欧拉函数（计算互质数的个数）</h3><p><strong>定义</strong>：φ(n)表示1~n中与n互质的数的个数<br>​<strong>计算公式</strong>​：若n = p₁^a × p₂^b × …（p为质因子）<br>则 φ(n) = n × (1-1/p₁) × (1-1/p₂) × …</p><p><strong>示例</strong>：<br>n = 6（质因子2,3）<br>φ(6) = 6 × (1-1/2) × (1-1/3) = 2<br>实际互质数：1,5</p><hr><h3 id="五、质数筛法（性能飞跃）">五、质数筛法（性能飞跃）</h3><h4 id="1-埃拉托斯特尼筛法">1. 埃拉托斯特尼筛法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出100以内的所有质数</span></span><br><span class="line"><span class="type">bool</span> isPrime[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">fill</span>(isPrime+<span class="number">2</span>, isPrime+<span class="number">101</span>, <span class="literal">true</span>); <span class="comment">// 初始假设2-100都是质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isPrime[i]) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*i; j&lt;=<span class="number">100</span>; j+=i)</span><br><span class="line">            isPrime[j] = <span class="literal">false</span>; <span class="comment">// 标记i的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：2 3 5 7 11 13 ... 97</span></span><br></pre></td></tr></table></figure><h4 id="2-欧拉线性筛法（最优时间复杂度）">2. 欧拉线性筛法（最优时间复杂度）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; primes;          <span class="comment">// 存储最终找到的所有质数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n+<span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// isPrime[i]表示i是否是质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> current = <span class="number">2</span>; current &lt;= n; current++) &#123;</span><br><span class="line">    <span class="comment">// 当前数字如果是质数，加入质数列表</span></span><br><span class="line">    <span class="keyword">if</span> (isPrime[current]) &#123;</span><br><span class="line">        primes.<span class="built_in">push_back</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用当前数字与已有质数生成合数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">        <span class="type">int</span> composite = current * prime;  <span class="comment">// 即将标记的合数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当合数超出范围时停止标记</span></span><br><span class="line">        <span class="keyword">if</span> (composite &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记这个合数为非质数</span></span><br><span class="line">        isPrime[composite] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心优化逻辑：保证每个合数只被其最小质因数标记</span></span><br><span class="line">        <span class="comment">// 当current能被当前质数整除时，后续质数会由更大的current处理</span></span><br><span class="line">        <span class="keyword">if</span> (current % prime == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终primes容器中将包含所有≤n的质数</span></span><br></pre></td></tr></table></figure><p><strong>筛法对比</strong></p><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>埃氏筛</td><td>O(n log n)</td><td>O(n)</td><td>普通规模数据</td></tr><tr><td>欧拉筛</td><td>O(n)</td><td>O(n)</td><td>大规模数据</td></tr></tbody></table><hr><h3 id="五、知识点综合应用">五、知识点综合应用</h3><p><strong>案例：质数间隔问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出区间[L, R]内相邻质数差的最大值</span></span><br><span class="line"><span class="type">int</span> maxGap = <span class="number">0</span>, prev = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=L; i&lt;=R; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isPrime[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="number">-1</span>) </span><br><span class="line">            maxGap = <span class="built_in">max</span>(maxGap, i - prev);</span><br><span class="line">        prev = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结合欧拉筛预处理+区间筛选优化</span></span><br></pre></td></tr></table></figure><hr><h2 id="📝-精选练习题">📝 <strong>精选练习题</strong></h2><h3 id="题目1：质数筛法应用">题目1：质数筛法应用</h3><p><strong>描述</strong>：输入两个数a,b（10 ≤ a &lt; b ≤ 100），输出[a,b]区间内所有质数<br>​<strong>样例输入</strong>​：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 30</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 29</span><br></pre></td></tr></table></figure><hr><h3 id="题目2：欧拉函数计算">题目2：欧拉函数计算</h3><p><strong>描述</strong>：输入正整数n（n ≤ 1000），输出φ(n)的值<br>​<strong>样例输入</strong>​：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  // 与8互质的数：1,3,5,7</span><br></pre></td></tr></table></figure><hr><h3 id="题目3：组合数递推验证">题目3：组合数递推验证</h3><p><strong>描述</strong>：输入n和k（1 ≤ k ≤ n ≤ 10），输出C(n,k)的值<br>​<strong>样例输入</strong>​：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><hr><h3 id="题目4：实数二分（适合学有余力）">题目4：实数二分（适合学有余力）</h3><p><strong>描述</strong>：计算√a的近似值（a&gt;1），保留3位小数<br>​<strong>输入</strong>​：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.414</span><br></pre></td></tr></table></figure><p><strong>解题提示</strong>：</p><ul><li>设置二分范围left=1, right=a</li><li>循环直到right-left &lt; 1e-4</li><li>mid = (left+right)/2，比较mid²与a的大小</li></ul><hr><h2 id="📚-学习建议">📚 <strong>学习建议</strong></h2><ol><li><strong>先掌握基础筛法</strong>：用埃氏筛法完成题目1</li><li><strong>理解公式再编程</strong>：通过题目2理解欧拉函数的计算逻辑</li><li><strong>画图辅助递推</strong>：用杨辉三角可视化题目3的递推过程</li><li><strong>精度控制训练</strong>：题目4建议手算验证后再写代码</li></ol><hr><h2 id="📝-学习路径导图">📝 <strong>学习路径导图</strong></h2><!-- ```mermaid --><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[二分答案2] --&gt; B[实数二分]A --&gt; C[递推基础]C --&gt; D[组合数递推]B --&gt; E[质数筛法]D --&gt; F[综合应用]E --&gt; F  </pre></div><!-- ``` -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L8 - 高阶算法与数论专题&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 &lt;strong&gt;教学目标&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握二分答案的复杂场景应用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建立递推思维解</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L7 - 算法优化与高效问题求解</title>
    <link href="https://whystars.cn/posts/23f1.html"/>
    <id>https://whystars.cn/posts/23f1.html</id>
    <published>2025-05-03T04:09:44.000Z</published>
    <updated>2025-05-03T06:06:19.291Z</updated>
    
    <content type="html"><![CDATA[<h1>L7 - 算法优化与高效问题求解</h1><hr><h2 id="🎯-教学目标">🎯 <strong>教学目标</strong></h2><ol><li><strong>掌握时间复杂度分析方法</strong>，能估算程序性能并优化算法</li><li><strong>熟练应用前缀和技巧</strong>，解决区间统计类问题</li><li><strong>深入理解二分法</strong>，实现查找与答案判定双重功能</li><li><strong>构建递归思维模型</strong>，学会用记忆化搜索优化重复计算</li></ol><hr><h2 id="📚-核心知识体系">📚 <strong>核心知识体系</strong></h2><h3 id="一、时间复杂度分析（理论基石）">一、时间复杂度分析（理论基石）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：比较两种算法的耗时差异</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo_O_n</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; <span class="comment">/* 操作 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo_O_n2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// O(n²)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123; <span class="comment">/* 操作 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度对比表</strong></p><table><thead><tr><th>数据规模</th><th>O(n)（毫秒）</th><th>O(n²)（毫秒）</th></tr></thead><tbody><tr><td>n=1e3</td><td>1</td><td>1000</td></tr><tr><td>n=1e4</td><td>10</td><td>100000</td></tr></tbody></table><hr><h3 id="二、前缀和与差分数组（区间处理利器）">二、前缀和与差分数组（区间处理利器）</h3><h4 id="1-一维前缀和模板">1. 一维前缀和模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">    preSum[i+<span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询区间[a,b]和：preSum[b+1] - preSum[a]</span></span><br></pre></td></tr></table></figure><h4 id="2-二维前缀和应用">2. 二维前缀和应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵区域和计算</span></span><br><span class="line">sum = preSum[x2][y2] - preSum[x1<span class="number">-1</span>][y2] </span><br><span class="line">      - preSum[x2][y1<span class="number">-1</span>] + preSum[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><hr><h3 id="三、二分法双模式（查找与答案判定）">三、二分法双模式（查找与答案判定）</h3><h4 id="1-经典二分查找">1. 经典二分查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>, right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-二分答案框架">2. 二分答案框架</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxValue</span><span class="params">(<span class="type">int</span> maxLimit)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>, right=maxLimit;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 取右中位数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) left = mid;  <span class="comment">// check函数验证答案可行性</span></span><br><span class="line">        <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、递归与记忆化搜索（性能飞跃）">四、递归与记忆化搜索（性能飞跃）</h3><h4 id="1-递归三要素实现">1. 递归三要素实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;                <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>); <span class="comment">// 递归公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-记忆化搜索优化">2. 记忆化搜索优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibMemo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo.<span class="built_in">count</span>(n)) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="keyword">return</span> memo[n] = <span class="built_in">fibMemo</span>(n<span class="number">-1</span>) + <span class="built_in">fibMemo</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能对比</strong></p><table><thead><tr><th>算法</th><th>计算fib(40)时间</th><th>时间复杂度</th></tr></thead><tbody><tr><td>普通递归</td><td>＞60秒</td><td>O(2ⁿ)</td></tr><tr><td>记忆化搜索</td><td>＜1毫秒</td><td>O(n)</td></tr></tbody></table><hr><h2 id="🧩-综合应用案例">🧩 <strong>综合应用案例</strong></h2><h3 id="山脉数组查找目标值（融合二分与递归）">山脉数组查找目标值（融合二分与递归）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="type">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 步骤1：二分查找峰值点</span></span><br><span class="line">    <span class="type">int</span> peak = <span class="built_in">findPeak</span>(mountainArr);</span><br><span class="line">    <span class="comment">// 步骤2：左半区升序二分</span></span><br><span class="line">    <span class="type">int</span> leftRes = <span class="built_in">binarySearch</span>(mountainArr, <span class="number">0</span>, peak, target, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(leftRes != <span class="number">-1</span>) <span class="keyword">return</span> leftRes;</span><br><span class="line">    <span class="comment">// 步骤3：右半区降序二分</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binarySearch</span>(mountainArr, peak+<span class="number">1</span>, mountainArr.<span class="built_in">length</span>()<span class="number">-1</span>, target, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🏋️-配套训练体系">🏋️ <strong>配套训练体系</strong></h2><h3 id="1-时间复杂度分析训练">1. 时间复杂度分析训练</h3><p><strong>题目1：基础复杂度判定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请分析以下代码的时间复杂度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i+=<span class="number">2</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目2：算法对比决策</strong><br>假设计算机每秒处理1e6次操作，当n=1e5时：</p><ul><li>算法A：时间复杂度O(n√n)，需要预处理1秒</li><li>算法B：时间复杂度O(n²)，无需预处理<br>应选择哪个算法？给出数学依据</li></ul><hr><h3 id="2-前缀和实战题单">2. 前缀和实战题单</h3><p><strong>题目1：子数组异或查询</strong>（LeetCode 1310）<br>» 给定数组，处理多个查询<code>[i,j]</code>，返回从i到j的异或结果<br>» 关键技巧：利用异或前缀性质<code>preXor[j+1] ^ preXor[i]</code></p><p><strong>题目2：航班预订统计</strong>（LeetCode 1109）<br>» 处理n个航班的预订记录<code>[first, last, seats]</code>，返回每日座位数<br>» 核心解法：差分数组+前缀和还原</p><p><strong>题目3：最大子矩阵</strong>（LeetCode 面试题17.24）<br>» 给定二维矩阵，找出元素和最大的子矩阵<br>» 高阶技巧：二维前缀和压缩+一维最大子数组转化</p><hr><h3 id="3-二分法专项训练">3. 二分法专项训练</h3><p><strong>题目1：寻找峰值</strong>（LeetCode 162）<br>» 数组可能包含多个峰值，返回任意一个峰值的索引<br>» 思维突破：比较mid与mid+1决定搜索方向</p><p><strong>题目2：H指数 II</strong>（LeetCode 275）<br>» 给定学者论文被引次数的升序数组，计算其H指数<br>» 判定条件设计：<code>citations[mid] &gt;= n - mid</code></p><p><strong>题目3：分割数组的最大值</strong>（LeetCode 410）<br>» 将数组分割为m个连续子数组，最小化最大子数组和<br>» 答案二分法典型应用：验证给定最大值是否可行</p><hr><h3 id="4-记忆化搜索挑战">4. 记忆化搜索挑战</h3><p><strong>题目1：带障碍的路径统计</strong>（LeetCode 63 改编）<br>» 网格中存在障碍物，求从左上角到右下角的路径数（允许→和↓移动）<br>» 进阶条件：若路径必须经过某特定点，如何修改记忆化策略</p><p><strong>题目2：硬币组合问题</strong>（LeetCode 518 改编）<br>» 给定不同面额的硬币和总金额，求凑成金额的硬币组合数<br>» 空间优化：如何将二维记忆化压缩为一维DP</p><p><strong>题目3：正则表达式匹配</strong>（LeetCode 10）<br>» 实现支持<code>.</code>和<code>*</code>的正则表达式匹配<br>» 记忆化技巧：用哈希表记录(i,j)位置的匹配结果</p><hr><h2 id="🧑💻-训练指导建议">🧑💻 <strong>训练指导建议</strong></h2><ol><li><strong>复杂度分析</strong>：使用<strong>主定理</strong>处理递归式，对比不同阶的增长曲线图</li><li><strong>前缀和题单</strong>：先手算推导矩阵区域和公式，再转化为代码实现</li><li><strong>二分训练</strong>：所有题目先用<strong>闭区间写法</strong>实现，再改为<strong>左闭右开</strong>对比差异</li><li><strong>记忆化搜索</strong>：先用树状图分析递归展开过程，再添加记忆化剪枝</li></ol><hr><h2 id="📝-学习路径导图">📝 <strong>学习路径导图</strong></h2><!-- ```mermaid --><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[时间复杂度] --&gt; B[前缀和&#x2F;差分]A --&gt; C[二分法]B --&gt; D[综合应用]C --&gt; DD --&gt; E[递归]E --&gt; F[记忆化搜索]F --&gt; G[动态规划基础]  </pre></div><!-- ``` -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L7 - 算法优化与高效问题求解&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 &lt;strong&gt;教学目标&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握时间复杂度分析方法&lt;/strong&gt;，能估算程序性能并优化算法&lt;/li&gt;
&lt;li&gt;&lt;s</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L6.1 - 指针与动态内存（拓展）</title>
    <link href="https://whystars.cn/posts/dd9a.html"/>
    <id>https://whystars.cn/posts/dd9a.html</id>
    <published>2025-05-03T04:09:43.000Z</published>
    <updated>2025-05-03T06:05:48.817Z</updated>
    
    <content type="html"><![CDATA[<h1>L6.1 - 指针与动态内存（拓展）</h1><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li>掌握指针运算与内存地址操作</li><li>熟练使用<code>new</code>/<code>delete</code>管理动态内存</li><li>理解智能指针的工作原理</li><li>掌握函数指针的高级应用</li><li>预防内存泄漏与悬空指针问题</li></ol><hr><h2 id="🔑-核心知识点">🔑 核心知识点</h2><h3 id="1-指针基础概念">1. 指针基础概念</h3><h4 id="内存地址可视化模型">内存地址可视化模型</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x1000 [ 10 ] ← int a = 10</span><br><span class="line">0x1004 [ 0x1000 ] ← int* p = &amp;a</span><br><span class="line">0x1008 [ 0x1004 ] ← int** pp = &amp;p</span><br></pre></td></tr></table></figure><p><strong>指针声明三要素：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;        <span class="comment">// 声明指针变量</span></span><br><span class="line">p = &amp;a;        <span class="comment">// 取地址操作</span></span><br><span class="line">cout &lt;&lt; *p;    <span class="comment">// 解引用操作</span></span><br></pre></td></tr></table></figure><h4 id="指针运算原理">指针运算原理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = arr;</span><br><span class="line"></span><br><span class="line">ptr + <span class="number">1</span> → 地址增加<span class="built_in">sizeof</span>(<span class="type">int</span>)（通常<span class="number">4</span>字节）</span><br><span class="line">*(ptr+<span class="number">3</span>) ← 等价于arr[<span class="number">3</span>]</span><br><span class="line">ptr++   ← 移动到下一个元素</span><br></pre></td></tr></table></figure><hr><h3 id="2-动态内存管理">2. 动态内存管理</h3><h4 id="内存分配生命周期图">内存分配生命周期图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐       ┌────────────┐</span><br><span class="line">│ 栈内存    │       │ 堆内存      │</span><br><span class="line">│ 自动回收  │ ← new │ 手动管理    │</span><br><span class="line">└───────────┘       └────────────┘</span><br></pre></td></tr></table></figure><p><strong>标准操作模板：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]; <span class="comment">// 分配数组</span></span><br><span class="line"><span class="keyword">delete</span>[] nums;            <span class="comment">// 释放数组</span></span><br><span class="line"></span><br><span class="line">Widget* w = <span class="keyword">new</span> <span class="built_in">Widget</span>(); <span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">delete</span> w;                 <span class="comment">// 销毁对象</span></span><br></pre></td></tr></table></figure><h4 id="多维数组动态分配">多维数组动态分配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** matrix = <span class="keyword">new</span> <span class="type">int</span>*[rows];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">    matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[cols];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] matrix;</span><br></pre></td></tr></table></figure><hr><h3 id="3-智能指针（Modern-C-）">3. 智能指针（Modern C++）</h3><h4 id="智能指针类型对比">智能指针类型对比</h4><table><thead><tr><th>类型</th><th>所有权</th><th>特点</th></tr></thead><tbody><tr><td>unique_ptr</td><td>独占</td><td>零开销，禁止拷贝</td></tr><tr><td>shared_ptr</td><td>共享</td><td>引用计数</td></tr><tr><td>weak_ptr</td><td>观察者</td><td>解决循环引用问题</td></tr></tbody></table><h4 id="使用示例">使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr（独占资源）</span></span><br><span class="line"><span class="keyword">auto</span> uptr = <span class="built_in">make_unique</span>&lt;Widget&gt;(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shared_ptr（共享资源）</span></span><br><span class="line"><span class="keyword">auto</span> sptr1 = <span class="built_in">make_shared</span>&lt;Resource&gt;(...);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1; <span class="comment">// 引用计数+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// weak_ptr（打破循环引用）</span></span><br><span class="line">shared_ptr&lt;Node&gt; node;</span><br><span class="line">weak_ptr&lt;Node&gt; parent;</span><br></pre></td></tr></table></figure><hr><h3 id="4-函数指针高级应用">4. 函数指针高级应用</h3><h4 id="回调函数系统设计">回调函数系统设计</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EventHandler)</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 定义函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    vector&lt;EventHandler&gt; handlers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addHandler</span><span class="params">(EventHandler h)</span> </span>&#123;</span><br><span class="line">        handlers.<span class="built_in">push_back</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> h : handlers) &#123;</span><br><span class="line">            <span class="built_in">h</span>(<span class="number">42</span>); <span class="comment">// 触发所有回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数指针数组">函数指针数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*operations[])(<span class="type">int</span>, <span class="type">int</span>) = &#123;</span><br><span class="line">    [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; cout &lt;&lt; a+b; &#125;,</span><br><span class="line">    [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; cout &lt;&lt; a-b; &#125;,</span><br><span class="line">    [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; cout &lt;&lt; a*b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line">operations[<span class="number">0</span>](<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// 执行加法</span></span><br></pre></td></tr></table></figure><hr><h2 id="💡-内存管理实战技巧">💡 内存管理实战技巧</h2><h3 id="内存泄漏检测方案">内存泄漏检测方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new new(_NORMAL_BLOCK, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序入口处添加</span></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br></pre></td></tr></table></figure><h3 id="安全指针使用规范">安全指针使用规范</h3><ol><li><strong>初始化原则</strong>：声明时立即初始化</li><li><strong>NULL检查</strong>：解引用前验证有效性</li><li><strong>所有权明确</strong>：遵循RAII原则</li><li><strong>禁止野指针</strong>：释放后立即置空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// 防止重复删除</span></span><br></pre></td></tr></table></figure><hr><h2 id="💣-高危内存问题解析">💣 高危内存问题解析</h2><h3 id="1-悬空指针（Dangling-Pointer）">1. 悬空指针（Dangling Pointer）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;num; <span class="comment">// 返回局部变量地址（危险！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">createNumber</span>();</span><br><span class="line">    cout &lt;&lt; *p; <span class="comment">// 访问已释放的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-内存泄漏（Memory-Leak）">2. 内存泄漏（Memory Leak）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leakyFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// 忘记delete[] arr</span></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 内存永久丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-双重释放（Double-Free）">3. 双重释放（Double Free）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line"><span class="keyword">delete</span>[] data; <span class="comment">// 二次释放导致崩溃</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧩-经典数据结构实现">🧩 经典数据结构实现</h2><h3 id="链表节点管理">链表节点管理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    unique_ptr&lt;Node&gt; next; <span class="comment">// 自动内存管理</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(unique_ptr&lt;Node&gt;&amp; head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newNode = <span class="built_in">make_unique</span>&lt;Node&gt;(val);</span><br><span class="line">    newNode-&gt;next = <span class="built_in">move</span>(head);</span><br><span class="line">    head = <span class="built_in">move</span>(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维矩阵类">二维矩阵类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">float</span>[]&gt; data;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r, <span class="type">int</span> c) : <span class="built_in">rows</span>(r), <span class="built_in">cols</span>(c), </span><br><span class="line">           <span class="built_in">data</span>(<span class="built_in">make_unique</span>&lt;<span class="type">float</span>[]&gt;(r*c)) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">float</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[r*cols + c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="🏋️-配套练习">🏋️ 配套练习</h2><h3 id="1-智能指针实战">1. 智能指针实战</h3><ul><li>实现学生管理系统：<ul><li>使用<code>shared_ptr</code>管理学生对象</li><li>实现课程选修关系（使用<code>weak_ptr</code>）</li><li>统计对象生命周期</li></ul></li></ul><h3 id="2-内存分配分析器">2. 内存分配分析器</h3><ul><li>编写内存跟踪器：<ul><li>重载<code>new</code>/<code>delete</code>记录分配信息</li><li>生成内存使用报告（包含泄漏检测）</li></ul></li></ul><h3 id="3-函数工厂模式">3. 函数工厂模式</h3><ul><li>创建运算工厂：<ul><li>根据字符串&quot;add&quot;/&quot;mul&quot;返回对应函数指针</li><li>支持动态扩展新运算</li></ul></li></ul><h3 id="4-自定义智能指针">4. 自定义智能指针</h3><ul><li><p>实现简化版<code>shared_ptr</code>：</p><ul><li>包含引用计数器</li><li>实现拷贝构造函数</li><li>支持<code>reset()</code>方法</li></ul></li></ul><h3 id="5-循环引用破解">5. 循环引用破解</h3><ul><li>设计双向链表：<ul><li>使用<code>shared_ptr</code>和<code>weak_ptr</code>实现</li><li>验证节点自动释放</li><li>对比不同实现的内存消耗</li></ul></li></ul><hr><h2 id="🛠️-调试工具指南">🛠️ 调试工具指南</h2><h3 id="Valgrind使用示例">Valgrind使用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full \</span><br><span class="line">         --show-reachable=<span class="built_in">yes</span> \</span><br><span class="line">         --track-origins=<span class="built_in">yes</span> \</span><br><span class="line">         ./your_program</span><br></pre></td></tr></table></figure><h3 id="AddressSanitizer配置">AddressSanitizer配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-fsanitize=address)</span><br><span class="line"><span class="keyword">add_link_options</span>(-fsanitize=address)</span><br></pre></td></tr></table></figure><h3 id="内存布局分析工具">内存布局分析工具</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;变量地址：&quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>*) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;内存对齐：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(MyClass) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L6.1 - 指针与动态内存（拓展）&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;掌握指针运算与内存地址操作&lt;/li&gt;
&lt;li&gt;熟练使用&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;管理动态内存&lt;/li</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L6 - 算法优化与多维数组</title>
    <link href="https://whystars.cn/posts/eeb5.html"/>
    <id>https://whystars.cn/posts/eeb5.html</id>
    <published>2025-05-03T04:09:42.000Z</published>
    <updated>2025-05-03T06:01:15.496Z</updated>
    
    <content type="html"><![CDATA[<h1>L6 - 算法优化与多维数组</h1><h2 id="📚-核心知识模块">📚 核心知识模块</h2><!-- ```mermaid --><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    L6[L6 算法与多维数组]    L6 --&gt; A[排序算法]    L6 --&gt; B[循环优化]    L6 --&gt; C[STL函数]    L6 --&gt; D[二维数组]        A --&gt; A1(冒泡排序)    A --&gt; A2(计数排序)    A --&gt; A3(算法对比)        B --&gt; B1(循环嵌套)    B --&gt; B2(流程控制)        C --&gt; C1(sort)    C --&gt; C2(swap)    C --&gt; C3(数学函数)        D --&gt; D1(动态创建)    D --&gt; D2(矩阵运算)&lt;!-- &#96;&#96;&#96; --&gt;  </pre></div><hr><h2 id="🔥-重点升级内容">🔥 重点升级内容</h2><h3 id="1-排序算法深度对比">1. 排序算法深度对比</h3><p><strong>冒泡排序模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>; <span class="comment">// 优化标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>; <span class="comment">// 提前终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数排序模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(arr, arr+n);</span><br><span class="line">    <span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[maxVal+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) count[arr[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=maxVal; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]--) arr[index++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法对比表</strong></p><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(1)</td><td>教学演示、小数据集</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(k)</td><td>整数范围较小的情况</td></tr><tr><td>STL sort</td><td>O(n log n)</td><td>O(log n)</td><td>通用场景</td></tr></tbody></table><hr><h3 id="2-STL函数实战">2. STL函数实战</h3><p><strong>内置函数应用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 快速排序</span></span><br><span class="line"><span class="built_in">sort</span>(arr, arr+n); <span class="comment">// 默认升序</span></span><br><span class="line"><span class="built_in">sort</span>(arr, arr+n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数值交换</span></span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 数学函数</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">16</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-5</span>);   <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-多维数组进阶">3. 多维数组进阶</h3><p><strong>动态二维数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">int</span>** matrix = <span class="keyword">new</span> <span class="type">int</span>*[rows];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[cols];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] matrix;</span><br></pre></td></tr></table></figure><p><strong>矩阵转置算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">(<span class="type">int</span>** mat, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(mat[i][j], mat[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-新增训练体系">🚀 新增训练体系</h2><h3 id="案例1：排序算法性能分析器">案例1：排序算法性能分析器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSort</span><span class="params">(<span class="type">void</span> (*sortFunc)(<span class="type">int</span>[], <span class="type">int</span>), <span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">sortFunc</span>(arr, n);</span><br><span class="line">    <span class="keyword">auto</span> end = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;耗时: &quot;</span> </span><br><span class="line">         &lt;&lt; chrono::<span class="built_in">duration_cast</span>&lt;microseconds&gt;(end-start).<span class="built_in">count</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot;μs&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="comment">/*...*/</span>&#125;, arr2[] = &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="built_in">testSort</span>(bubbleSort, arr1, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">testSort</span>(countingSort, arr2, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="案例2：成绩管理系统（二维数组版）">案例2：成绩管理系统（二维数组版）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SUBJECTS = <span class="number">3</span>; <span class="comment">// 语文、数学、英语</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入学生成绩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputScores</span><span class="params">(<span class="type">int</span>** scores, <span class="type">int</span> students)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;students; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;SUBJECTS; j++) &#123;</span><br><span class="line">            cin &gt;&gt; scores[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算学科平均分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcAverage</span><span class="params">(<span class="type">int</span>** scores, <span class="type">int</span> students)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;SUBJECTS; j++) &#123;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;students; i++) &#123;</span><br><span class="line">            sum += scores[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学科&quot;</span> &lt;&lt; j+<span class="number">1</span> &lt;&lt; <span class="string">&quot;平均分: &quot;</span> </span><br><span class="line">             &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; sum/students &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L6 - 算法优化与多维数组&lt;/h1&gt;
&lt;h2 id=&quot;📚-核心知识模块&quot;&gt;📚 核心知识模块&lt;/h2&gt;
&lt;!-- ```mermaid --&gt;
&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src&quot; hidden&gt;
  g</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L5 - 函数与递归</title>
    <link href="https://whystars.cn/posts/5529.html"/>
    <id>https://whystars.cn/posts/5529.html</id>
    <published>2025-05-03T04:09:41.000Z</published>
    <updated>2025-05-03T05:07:43.782Z</updated>
    
    <content type="html"><![CDATA[<h1>L5 - 函数与递归</h1><h2 id="🎯-教学目标深化">🎯 教学目标深化</h2><ol><li><strong>函数设计原则</strong><ul><li>单一职责原则（每个函数只做一件事）</li><li>合理控制函数体长度（建议不超过50行）</li><li>避免函数副作用（除非明确需要）</li></ul></li><li><strong>递归思维训练</strong><ul><li>分治思想的实现方式</li><li>递归树分析（用于理解递归执行路径）</li><li>递归与数学归纳法的关系</li></ul></li></ol><hr><h2 id="🔑-核心知识点扩展">🔑 核心知识点扩展</h2><h3 id="1-函数定义深度解析">1. 函数定义深度解析</h3><h4 id="函数声明与定义的分离">函数声明与定义的分离</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mymath.h（头文件）</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mymath.cpp（源文件）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 定义</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头文件作用：</strong></p><ul><li>提供接口文档</li><li>避免重复定义</li><li>支持模块化编译</li></ul><h4 id="默认参数机制">默认参数机制</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(string msg, <span class="type">int</span> level=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">printLog</span>(<span class="string">&quot;系统启动&quot;</span>);     <span class="comment">// 使用默认level=1</span></span><br><span class="line"><span class="built_in">printLog</span>(<span class="string">&quot;内存不足&quot;</span>, <span class="number">3</span>);  <span class="comment">// 显式指定level=3</span></span><br></pre></td></tr></table></figure><p><strong>规则说明：</strong></p><ul><li>默认参数必须从右向左连续设置</li><li>默认值在声明中指定（定义中不再重复）</li><li>默认参数慎用指针和引用类型</li></ul><hr><h3 id="2-参数传递机制对比（新增指针传递）">2. 参数传递机制对比（新增指针传递）</h3><table><thead><tr><th>传递方式</th><th>语法</th><th>内存操作</th><th>典型应用场景</th></tr></thead><tbody><tr><td>值传递</td><td><code>int a</code></td><td>创建参数副本</td><td>基础类型小数据</td></tr><tr><td>引用传递</td><td><code>int&amp; a</code></td><td>直接操作原变量</td><td>需要修改实参</td></tr><tr><td>指针传递</td><td><code>int* a</code></td><td>操作地址指向数据</td><td>可选参数/动态结构</td></tr></tbody></table><p><strong>指针传递示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByPointer</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">int</span> newVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>) &#123; <span class="comment">// 安全检查</span></span><br><span class="line">        *ptr = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modifyByPointer</span>(&amp;value, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; value; <span class="comment">// 输出20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-递归算法高级应用">3. 递归算法高级应用</h3><h4 id="递归调用栈可视化">递归调用栈可视化</h4><p><strong>阶乘递归的栈空间变化：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| factorial(3)  | → 分配n=3</span><br><span class="line">| factorial(2)  | → 分配n=2</span><br><span class="line">| factorial(1)   | → 分配n=1</span><br><span class="line">| return 1       | ← 释放n=1</span><br><span class="line">| return 2 * 1=2   | ← 释放n=2</span><br><span class="line">| return 3 * 2=6   | ← 释放n=3</span><br></pre></td></tr></table></figure><h4 id="尾递归优化原理">尾递归优化原理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="built_in">sum</span>(n<span class="number">-1</span>); <span class="comment">// 需要保存上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归优化版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumTail</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> acc=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> acc;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sumTail</span>(n<span class="number">-1</span>, acc+n); <span class="comment">// 无上下文依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器优化效果：</strong></p><ul><li>将尾递归转换为循环结构</li><li>避免栈溢出风险</li><li>时间复杂度从O(n)降为O(1)（空间复杂度）</li></ul><hr><h2 id="💡-进阶技巧">💡 进阶技巧</h2><h3 id="1-函数指针应用">1. 函数指针应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数指针参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">int</span> data, Callback cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...处理数据</span></span><br><span class="line">    <span class="built_in">cb</span>(result); <span class="comment">// 回调通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printResult</span><span class="params">(<span class="type">int</span> result)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;处理结果：&quot;</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">processData</span>(<span class="number">100</span>, printResult);</span><br></pre></td></tr></table></figure><h3 id="2-函数重载规则">2. 函数重载规则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="comment">/* 处理整型 */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123; <span class="comment">/* 处理浮点型 */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string str)</span> </span>&#123; <span class="comment">/* 处理字符串 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时自动匹配最佳版本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>);     <span class="comment">// 调用int版</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3.14</span>);   <span class="comment">// 调用double版</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 调用string版</span></span><br></pre></td></tr></table></figure><p><strong>重载解析规则：</strong></p><ol><li>精确匹配</li><li>类型提升（char→int）</li><li>标准转换（int→double）</li><li>用户定义转换</li></ol><hr><h2 id="🧩-经典算法深度实现">🧩 经典算法深度实现</h2><h3 id="1-快速排序递归实现">1. 快速排序递归实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(arr, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, left, pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, pivot+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];</span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=left; j&lt;right; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i+<span class="number">1</span>], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程图示：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始数组：[<span class="string">5</span>][<span class="symbol">3</span>][<span class="string">8</span>][<span class="symbol">6</span>][<span class="string">4</span>][<span class="symbol">7</span>][<span class="string">1</span>][<span class="symbol">2</span>]</span><br><span class="line">首趟分区：选取2为基准 → [<span class="string">1</span>][<span class="symbol">3</span>][<span class="string">4</span>][<span class="symbol">5</span>][<span class="string">6</span>][<span class="symbol">8</span>][<span class="string">7</span>][<span class="symbol">2</span>]</span><br><span class="line">递归处理左右子数组</span><br></pre></td></tr></table></figure><h3 id="2-二叉树遍历（先序递归）">2. 二叉树遍历（先序递归）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问根</span></span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);     <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);    <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归树分析：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">      1</span></span><br><span class="line"><span class="code">     / \</span></span><br><span class="line"><span class="code">    2   3</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  4   5</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">遍历顺序：1 → 2 → 4 → 5 → 3</span><br></pre></td></tr></table></figure><hr><h2 id="💣-易错点深度剖析">💣 易错点深度剖析</h2><h3 id="1-栈溢出问题">1. 栈溢出问题</h3><p><strong>错误案例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>); <span class="comment">// 指数级递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算fib(40)将导致数百万次调用</span></span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><ul><li>改用迭代法</li><li>记忆化缓存（存储已计算结果）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibMemo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(cache.<span class="built_in">count</span>(n)) <span class="keyword">return</span> cache[n];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">fibMemo</span>(n<span class="number">-1</span>) + <span class="built_in">fibMemo</span>(n<span class="number">-2</span>);</span><br><span class="line">    cache[n] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-引用传递陷阱">2. 引用传递陷阱</h3><p><strong>未预期的修改：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initArray</span><span class="params">(<span class="type">int</span>&amp; arr)</span> </span>&#123; <span class="comment">// 错误！数组引用语法错误</span></span><br><span class="line">    arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initArray</span><span class="params">(<span class="type">int</span>*&amp; arr)</span> </span>&#123; <span class="comment">// 引用传递指针</span></span><br><span class="line">    arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-高级调试技巧">🛠️ 高级调试技巧</h2><h3 id="1-递归调用追踪">1. 递归调用追踪</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 全局变量记录递归深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    depth++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进入递归层数：&quot;</span> &lt;&lt; depth &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;触底返回&quot;</span> &lt;&lt; endl;</span><br><span class="line">        depth--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">recursiveFunc</span>(n<span class="number">-1</span>);</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出示例：</span></span><br><span class="line"><span class="comment">// 进入递归层数：1</span></span><br><span class="line"><span class="comment">// 进入递归层数：2</span></span><br><span class="line"><span class="comment">// 触底返回</span></span><br></pre></td></tr></table></figure><h3 id="2-内存泄漏检测">2. 内存泄漏检测</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// ...未释放内存...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Valgrind工具检测：</span></span><br><span class="line"><span class="comment">// valgrind --leak-check=full ./a.out</span></span><br></pre></td></tr></table></figure><hr><h2 id="🏋️-配套练习升级">🏋️ 配套练习升级</h2><h3 id="1-函数性能对比器">1. 函数性能对比器</h3><p><strong>要求：</strong></p><ul><li>实现时间测量装饰器函数</li><li>对比递归与迭代版的斐波那契计算效率</li><li>输出不同规模下的耗时曲线</li></ul><p><strong>参考代码框架：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">measureTime</span><span class="params">(Func func, string title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">auto</span> end = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout &lt;&lt; title &lt;&lt; <span class="string">&quot;耗时: &quot;</span> </span><br><span class="line">         &lt;&lt; chrono::<span class="built_in">duration_cast</span>&lt;milliseconds&gt;(end-start).<span class="built_in">count</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="built_in">measureTime</span>([]&#123;<span class="built_in">fibRecursive</span>(<span class="number">35</span>);&#125;, <span class="string">&quot;递归版&quot;</span>);</span><br><span class="line"><span class="built_in">measureTime</span>([]&#123;<span class="built_in">fibIterative</span>(<span class="number">35</span>);&#125;, <span class="string">&quot;迭代版&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-表达式解析器">2. 表达式解析器</h3><p><strong>要求：</strong></p><ul><li>实现递归下降解析器</li><li>支持四则运算和括号</li><li>示例输入：“3*(2+4)/2”</li><li>示例输出：9</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L5 - 函数与递归&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标深化&quot;&gt;🎯 教学目标深化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;函数设计原则&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（每个函数只做一件事）&lt;/li&gt;
&lt;li&gt;合理控制函数体长度（建议不超过50</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L4 - 条件分支与逻辑运算</title>
    <link href="https://whystars.cn/posts/bba5.html"/>
    <id>https://whystars.cn/posts/bba5.html</id>
    <published>2025-05-03T04:09:40.000Z</published>
    <updated>2025-05-03T05:07:38.419Z</updated>
    
    <content type="html"><![CDATA[<h1>L4 - 条件分支与逻辑运算</h1><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li>掌握多条件判断的嵌套写法</li><li>理解逻辑运算符的优先级规则</li><li>能处理复合条件判断问题</li><li>应用短路运算优化代码逻辑</li></ol><h2 id="🔑-核心知识点">🔑 核心知识点</h2><h3 id="多条件判断模板">多条件判断模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三分支温度预警系统</span></span><br><span class="line"><span class="keyword">if</span>(temp &gt; <span class="number">35</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;红色高温预警&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; <span class="number">30</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;橙色高温预警&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正常温度范围&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程解析：</strong></p><ol><li>严格顺序检查条件</li><li>首个满足条件的分支执行后立即退出</li><li><code>else if</code>本质是嵌套的<code>if</code>语句的语法糖</li><li>推荐使用大括号明确作用域，避免悬空else问题</li></ol><h3 id="逻辑运算符优先级表">逻辑运算符优先级表</h3><table><thead><tr><th>运算符</th><th>描述</th><th>优先级</th><th>结合性</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td>3</td><td>右到左</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>11</td><td>左到右</td></tr><tr><td>||</td><td>逻辑或</td><td>12</td><td>左到右</td></tr></tbody></table><p><strong>经典案例解析：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">5</span> || b &lt; <span class="number">3</span> &amp;&amp; c == <span class="number">10</span>) </span><br><span class="line"><span class="comment">// 等效于：a&gt;5 || (b&lt;3 &amp;&amp; c==10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((x != <span class="number">0</span>) &amp;&amp; (y/x &gt; <span class="number">0.5</span>)) </span><br><span class="line"><span class="comment">// 安全除法：利用短路特性避免除零错误</span></span><br></pre></td></tr></table></figure><h2 id="⚡-短路运算深度解析">⚡ 短路运算深度解析</h2><h3 id="短路机制示意图">短路机制示意图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &amp;&amp; B → 当A为<span class="literal">false</span>时，B不执行</span><br><span class="line">A || B → 当A为<span class="literal">true</span>时，B不执行</span><br></pre></td></tr></table></figure><p><strong>实际应用案例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全指针访问</span></span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;<span class="built_in">isValid</span>())&#123;</span><br><span class="line">    <span class="comment">// 安全访问指针成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效循环终止</span></span><br><span class="line"><span class="keyword">while</span>(index &lt; SIZE &amp;&amp; array[index] != target)&#123;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能优化实验">性能优化实验</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; <span class="comment">/* 耗时操作 */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123; <span class="comment">/* 简单判断 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化前：总执行funcA()</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">funcA</span>() || <span class="built_in">funcB</span>()) &#123;...&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后：funcB()可能跳过funcA()</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">funcB</span>() || <span class="built_in">funcA</span>()) &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="🕹️-互动案例系统">🕹️ 互动案例系统</h2><h3 id="闰年判断器（ISO标准）">闰年判断器（ISO标准）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span>) || (year%<span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例集：</strong></p><table><thead><tr><th>年份</th><th>预期结果</th><th>测试要点</th></tr></thead><tbody><tr><td>2000</td><td>true</td><td>世纪闰年</td></tr><tr><td>1900</td><td>false</td><td>世纪非闰年</td></tr><tr><td>2020</td><td>true</td><td>普通闰年</td></tr><tr><td>2021</td><td>false</td><td>平年</td></tr></tbody></table><h3 id="成绩等级转换系统">成绩等级转换系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">getGrade</span><span class="params">(<span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>) <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">80</span>) <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>; <span class="comment">// 隐含score&lt;90</span></span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">70</span>) <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;D&#x27;</span>; <span class="comment">// 低于70分的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>条件覆盖分析：</strong></p><ul><li>边界值测试：89,90,0,100</li><li>非法值处理：负分、超过100分</li><li>数据类型验证：浮点数输入处理</li></ul><h2 id="💣-易错点详解">💣 易错点详解</h2><h3 id="运算符优先级陷阱">运算符优先级陷阱</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &amp; <span class="number">1</span> == <span class="number">0</span>) <span class="comment">// 实际解析：a &amp; (1 == 0)</span></span><br><span class="line"><span class="comment">// 正确写法：(a &amp; 1) == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">5</span> || <span class="number">10</span> &lt; x &lt; <span class="number">20</span>) <span class="comment">// 错误逻辑！</span></span><br><span class="line"><span class="comment">// 正确表达：(x &lt;5 || (x&gt;10 &amp;&amp; x&lt;20))</span></span><br></pre></td></tr></table></figure><h3 id="浮点数比较危机">浮点数比较危机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">0.3</span>) <span class="comment">// 永远为false！</span></span><br><span class="line"><span class="comment">// 正确方法：fabs(d - 0.3) &lt; 1e-6</span></span><br></pre></td></tr></table></figure><h3 id="悬空else问题">悬空else问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 实际匹配内层if</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line"><span class="comment">// 通过大括号明确归属关系</span></span><br></pre></td></tr></table></figure><h2 id="🛠️-调试技巧">🛠️ 调试技巧</h2><h3 id="条件追踪法">条件追踪法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">   (cout &lt;&lt; <span class="string">&quot;检查条件1:&quot;</span> &lt;&lt; cond1 &lt;&lt; endl, cond1) &amp;&amp;</span><br><span class="line">   (cout &lt;&lt; <span class="string">&quot;检查条件2:&quot;</span> &lt;&lt; cond2 &lt;&lt; endl, cond2)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   cond1 &amp;&amp; cond2</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真值表验证法">真值表验证法</h3><table><thead><tr><th>A</th><th>B</th><th>A&amp;&amp;B</th><th>A||B</th><th>!A</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><strong>应用场景：</strong></p><ul><li>验证复杂逻辑表达式的所有可能情况</li><li>生成测试用例确保条件覆盖</li></ul><hr><h2 id="🎓-教学提示">🎓 教学提示</h2><h3 id="个人所得税计算器实现要点">个人所得税计算器实现要点</h3><ol><li><strong>税率区间处理：</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(income &gt; <span class="number">30000</span>) &#123;</span><br><span class="line">    tax += (income<span class="number">-30000</span>)*<span class="number">0.2</span>;</span><br><span class="line">    income = <span class="number">30000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(income &gt; <span class="number">17000</span>) &#123;</span><br><span class="line">    tax += (income<span class="number">-17000</span>)*<span class="number">0.1</span>;</span><br><span class="line">    income = <span class="number">17000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...后续区间类似处理</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>精度处理方法：</strong></li></ol><ul><li>使用<code>round(tax*100)/100</code>进行四舍五入</li><li>输出时使用<code>fixed &lt;&lt; setprecision(2)</code></li></ul><h3 id="电梯调度系统逻辑框架">电梯调度系统逻辑框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> current = <span class="number">5</span>; <span class="comment">// 当前楼层</span></span><br><span class="line"><span class="type">int</span> target = <span class="number">8</span>;  <span class="comment">// 目标楼层</span></span><br><span class="line"></span><br><span class="line">string direction = (target &gt; current) ? <span class="string">&quot;上行&quot;</span> : <span class="string">&quot;下行&quot;</span>;</span><br><span class="line"><span class="type">int</span> floors = <span class="built_in">abs</span>(target - current);</span><br><span class="line"><span class="type">int</span> time = floors * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;方向：&quot;</span> &lt;&lt; direction &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;预计耗时：&quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超载检测</span></span><br><span class="line"><span class="keyword">if</span>(totalWeight &gt; <span class="number">1000</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;警告！超载&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🏋️-配套练习">🏋️ 配套练习</h2><ol><li><p><strong>智能闰年检测</strong></p><ul><li>输入：年份（1-9999）</li><li>输出：<ul><li>闰年判断结果</li><li>带世纪年说明（如2000是世纪闰年）</li></ul></li></ul></li><li><p><strong>三角形检察官</strong></p><ul><li>输入：三个边长</li><li>输出：<ul><li>类型（普通/等腰/等边）</li><li>是否直角三角形（误差&lt;0.001）</li></ul></li></ul></li><li><p><strong>自动售票机系统</strong></p><ul><li>输入：票价、投入金额</li><li>输出：<ul><li>应找零钱（优先用大面额）</li><li>示例：<br>输入：46 100<br>输出：<br>50元×1<br>1元×4</li></ul></li></ul></li><li><p><strong>个人所得税计算器</strong></p><ul><li>规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0-5000：0%</span><br><span class="line">5000-8000：3%</span><br><span class="line">8000-17000：10%</span><br><span class="line">17000-30000：20%</span><br></pre></td></tr></table></figure></li><li>输入：月收入</li><li>输出：应纳税额（精确到分）</li></ul></li><li><p><strong>电梯调度系统</strong></p><ul><li>输入：当前楼层，目标楼层</li><li>输出：<ul><li>运行方向（上行/下行/停留）</li><li>预计到达时间（每层2秒）</li><li>超载检测（假设载重≤1000kg）</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L4 - 条件分支与逻辑运算&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;掌握多条件判断的嵌套写法&lt;/li&gt;
&lt;li&gt;理解逻辑运算符的优先级规则&lt;/li&gt;
&lt;li&gt;能处理复合条件判断问题&lt;/li&gt;
&lt;li&gt;应用短路运算优化代码逻</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L3 - 一维数组实战</title>
    <link href="https://whystars.cn/posts/f038.html"/>
    <id>https://whystars.cn/posts/f038.html</id>
    <published>2025-05-03T04:09:39.000Z</published>
    <updated>2025-05-03T06:04:17.595Z</updated>
    
    <content type="html"><![CDATA[<h1>L3 - 一维数组实战</h1><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li>掌握数组的声明与初始化</li><li>熟练使用循环处理数组元素</li><li>实现基础统计算法</li></ol><h2 id="🔑-核心知识点">🔑 核心知识点</h2><h3 id="数组声明与初始化">数组声明与初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准声明方式</span></span><br><span class="line"><span class="type">int</span> scores[<span class="number">5</span>];          <span class="comment">// 声明包含5个整数的数组（未初始化）</span></span><br><span class="line"><span class="type">float</span> temps[<span class="number">7</span>] = &#123;&#125;;    <span class="comment">// 全部初始化为0.0</span></span><br><span class="line"><span class="type">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;; <span class="comment">// 自动推导长度</span></span><br></pre></td></tr></table></figure><p><strong>关键要点：</strong></p><ol><li><p><strong>内存分配原理</strong>：</p><ul><li>连续内存块分配</li><li>每个元素占数据类型对应字节数（int通常4字节）</li><li>数组总大小 = 元素个数 × <strong>sizeof</strong>(元素类型)</li></ul></li><li><p><strong>初始化规则</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>];            <span class="comment">// 值随机（危险！）</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;    <span class="comment">// [1,2,0]</span></span><br><span class="line"><span class="type">int</span> arr3[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;   <span class="comment">// 长度自动推导为3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>访问机制</strong>：</p><ul><li>索引从0开始计算</li><li>通过首地址偏移访问元素</li><li>arr[i] 等效于 *(arr + i)</li></ul></li></ol><h3 id="数组遍历标准模板">数组遍历标准模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>; <span class="comment">// 最佳实践：用常量表示数组长度</span></span><br><span class="line"><span class="type">int</span> nums[N] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;  <span class="comment">// 严格使用 &lt; 避免越界</span></span><br><span class="line">    cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程解析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存地址 | 0x1000 | 0x1004 | 0x1008 | 0x100C | 0x1010</span><br><span class="line">元素值   |   3    |   1    |   4    |   1    |   5</span><br><span class="line">索引     |  [0]   |  [1]   |  [2]   |  [3]   |  [4]</span><br></pre></td></tr></table></figure><h2 id="📊-数据处理算法">📊 数据处理算法</h2><h3 id="求最大值算法">求最大值算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];        <span class="comment">// 假设第一个元素最大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;size; i++)&#123;  <span class="comment">// 从第二个元素开始比较</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; maxVal)&#123;</span><br><span class="line">            maxVal = arr[i];    <span class="comment">// 更新最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法优化技巧：</strong></p><ul><li>初始值设为<code>INT_MIN</code>可处理全负数数组</li><li>可同步记录最大值索引</li><li>时间复杂度：O(n)</li></ul><h3 id="逆序存储算法">逆序存储算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;             <span class="comment">// 首指针</span></span><br><span class="line">    <span class="type">int</span> right = size - <span class="number">1</span>;     <span class="comment">// 尾指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;     <span class="comment">// 双指针向中间移动</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存变化演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组：[1][2][3][4][5]</span><br><span class="line">第1次交换：[5][2][3][4][1]</span><br><span class="line">第2次交换：[5][4][3][2][1]</span><br><span class="line">终止条件：left=2, right=2</span><br></pre></td></tr></table></figure><h2 id="💡-特别提示">💡 特别提示</h2><h3 id="数组越界陷阱">数组越界陷阱</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; arr[<span class="number">3</span>]; <span class="comment">// 访问非法内存（索引0-2有效）</span></span><br></pre></td></tr></table></figure><ul><li>可能后果：<ul><li>输出垃圾值</li><li>程序崩溃（Segment Fault）</li><li>覆盖其他变量内存</li></ul></li></ul><h3 id="字符数组注意事项">字符数组注意事项</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 错误！需要6个位置（含\0）</span></span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 合法但不安全</span></span><br><span class="line"><span class="type">char</span> str3[] = <span class="string">&quot;world&quot;</span>;   <span class="comment">// 自动分配6字节</span></span><br></pre></td></tr></table></figure><p><strong>字符串处理要点：</strong></p><ul><li>使用<code>strlen()</code>获取实际长度</li><li><code>cin.getline(str, size)</code>安全输入</li><li>末尾必须保留<code>\0</code></li></ul><h2 id="💣-易错点详解">💣 易错点详解</h2><ol><li><p><strong>变量定义数组长度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[n]; <span class="comment">// C99允许，但C++标准禁止！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>越界访问导致数据污染</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;  <span class="comment">// 实际修改了a的值！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数组整体赋值错误</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>];</span><br><span class="line">arr2 = arr1; <span class="comment">// 错误！数组不能直接赋值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>误用sizeof计算元素个数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(arr); <span class="comment">// 错误！返回总字节数</span></span><br><span class="line"><span class="comment">// 正确写法：sizeof(arr)/sizeof(arr[0])</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="🛠️-调试技巧">🛠️ 调试技巧</h2><h3 id="数组内容可视化调试">数组内容可视化调试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试专用输出函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;索引\t地址\t值\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; &amp;arr[i] </span><br><span class="line">             &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">索引  地址        值</span><br><span class="line">0     0x7ffeed0a 10</span><br><span class="line">1     0x7ffeed0e 20</span><br><span class="line">2     0x7ffeed12 30</span><br></pre></td></tr></table></figure><h3 id="边界值测试策略">边界值测试策略</h3><ol><li>空数组测试（size=0）</li><li>单元素数组测试</li><li>全相同元素数组</li><li>极值测试（INT_MAX/MIN）</li></ol><hr><h2 id="🏋️-配套练习">🏋️ 配套练习</h2><ol><li><p><strong>成绩分析系统</strong></p><ul><li>输入：n个学生成绩（0-100）</li><li>输出：<ul><li>平均分（保留2位小数）</li><li>最高分及人数</li><li>各分数段分布（0-59,60-69,…）</li></ul></li></ul></li><li><p><strong>元素查找器</strong></p><ul><li>输入：长度为10的数组，1个目标数</li><li>输出：<ul><li>首次出现位置（从1开始）</li><li>最后一次出现位置</li><li>未找到时输出&quot;Not Found&quot;</li></ul></li></ul></li><li><p><strong>数组洗牌器</strong></p><ul><li>输入：数组长度n，数组元素</li><li>输出：<ul><li>奇数在前偶数在后，相对顺序不变</li><li>示例：<br>输入：5 [2,5,8,3,6]<br>输出：5 3 2 8 6</li></ul></li></ul></li><li><p><strong>矩阵转置器</strong></p><ul><li>输入：3x3矩阵</li><li>输出：转置矩阵<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">输出：</span><br><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>凯撒密码加密机</strong></p><ul><li>输入：字符串（仅字母），偏移量</li><li>输出：加密结果（Z后回到A）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ATTACK 3</span><br><span class="line">输出：DWWDFN</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L3 - 一维数组实战&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;掌握数组的声明与初始化&lt;/li&gt;
&lt;li&gt;熟练使用循环处理数组元素&lt;/li&gt;
&lt;li&gt;实现基础统计算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;🔑-核心知识点&quot;</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L2 - for循环与嵌套逻辑</title>
    <link href="https://whystars.cn/posts/e3b2.html"/>
    <id>https://whystars.cn/posts/e3b2.html</id>
    <published>2025-05-03T04:09:38.000Z</published>
    <updated>2025-05-03T05:07:31.903Z</updated>
    
    <content type="html"><![CDATA[<h1>L2 - for循环与嵌套逻辑</h1><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li>掌握for循环执行流程</li><li>理解循环变量的作用域</li><li>能处理双重循环嵌套问题</li></ol><h2 id="🔑-核心知识点">🔑 核心知识点</h2><h3 id="基础for循环结构">基础for循环结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><p><strong>执行流程详解：</strong></p><ol><li><strong>初始化阶段</strong>：<code>int i=0</code>（仅在循环开始时执行一次）</li><li><strong>条件判断</strong>：<code>i&lt;10</code>（每次循环前检查）<ul><li>若为<code>true</code> → 执行循环体</li><li>若为<code>false</code> → 退出循环</li></ul></li><li><strong>迭代操作</strong>：<code>i++</code>（每次循环体执行完毕后执行）</li><li><strong>循环周期</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化 → 判断 → 执行体 → 迭代 → 判断 → ...</span><br></pre></td></tr></table></figure></li></ol><p><strong>变量作用域规则：</strong></p><ul><li>循环变量<code>i</code>仅在<code>for</code>语句块内有效</li><li>若在循环外访问<code>i</code>将导致编译错误</li><li>可通过外部声明扩展作用域：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// 声明在外部</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">cout &lt;&lt; i; <span class="comment">// 此时i=10</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="嵌套循环模板">嵌套循环模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印3行5列的星号矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">3</span>; row++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt;<span class="number">5</span>; col++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 换行在行循环内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">*****</span></span><br><span class="line"><span class="comment">*****</span></span><br><span class="line"><span class="comment">*****</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>执行特征分析：</strong></p><ol><li><strong>外层循环控制行数</strong>：决定整体结构层数</li><li><strong>内层循环控制列数</strong>：处理每行的细节元素</li><li><strong>执行次数计算</strong>：外层次数 × 内层次数（本例3×5=15次）</li><li><strong>内存消耗</strong>：每层循环变量独立存储</li></ol><h2 id="📚-进阶技巧">📚 进阶技巧</h2><h3 id="循环控制语句">循环控制语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break示例：遇到4立即终止循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// continue示例：跳过奇数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 2 4 6 8 </span></span><br></pre></td></tr></table></figure><p><strong>关键区别：</strong></p><table><thead><tr><th></th><th>break</th><th>continue</th></tr></thead><tbody><tr><td>作用范围</td><td>当前整个循环</td><td>本次循环迭代</td></tr><tr><td>典型应用</td><td>提前退出条件</td><td>跳过特定情况</td></tr><tr><td>嵌套影响</td><td>只影响所在层</td><td>只影响所在层</td></tr></tbody></table><h3 id="调试案例解析">调试案例解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死循环示例分析</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; i++)&#123; <span class="comment">// 错误点：i++导致i永远&gt;0</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调试步骤：</strong></p><ol><li><strong>定位循环条件</strong>：<code>i&gt;0</code></li><li><strong>追踪变量变化</strong>：初始i=5 → 每次+1 → 6,7,8…</li><li><strong>发现矛盾点</strong>：迭代方向与条件判断矛盾</li><li><strong>修正方案</strong>：应改为<code>i--</code></li></ol><h2 id="🧩-经典算法实现">🧩 经典算法实现</h2><h3 id="九九乘法表">九九乘法表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot;×&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i*j &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现原理：</strong></p><ol><li><strong>外层循环</strong>：控制被乘数（1-9）</li><li><strong>内层循环</strong>：控制乘数（1到当前被乘数）</li><li><strong>输出对齐</strong>：使用<code>\t</code>制表符保持列对齐</li><li><strong>迭代关系</strong>：每行元素个数=行号</li></ol><p><strong>执行过程模拟（以i=3为例）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=3时：</span><br><span class="line">j循环执行3次：</span><br><span class="line">1×3=32×3=63×3=9</span><br><span class="line">换行</span><br></pre></td></tr></table></figure><h2 id="💣-易错点详解">💣 易错点详解</h2><ol><li><p><strong>循环条件设置错误</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">5</span>; i++) <span class="comment">// 执行6次（0-5）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++)  <span class="comment">// 执行4次（1-4）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套循环变量混淆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123; <span class="comment">// 内层覆盖外层i</span></span><br><span class="line">        cout &lt;&lt; i; <span class="comment">// 输出0-4（错误！）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代语句位置错误</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( ; i&lt;<span class="number">5</span>; )&#123; </span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">    i++; <span class="comment">// 必须手动增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>浮点数循环陷阱</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span> d=<span class="number">0.1</span>; d!=<span class="number">1.0</span>; d+=<span class="number">0.1</span>) </span><br><span class="line"><span class="comment">// 浮点精度问题可能导致无限循环</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="🛠️-调试技巧">🛠️ 调试技巧</h2><ol><li><p><strong>输出中间变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前i值：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用调试器观察点</strong></p><ul><li>在IDE中设置变量监控</li><li>单步执行观察循环流程</li></ul></li><li><p><strong>边界条件测试</strong></p><ul><li>测试循环的第一次和最后一次迭代</li><li>验证初始值和终止条件</li></ul></li><li><p><strong>复杂度预估</strong></p><ul><li>对嵌套循环进行时间复杂度分析：<ul><li>单层O(n)</li><li>双层O(n²)</li><li>三层O(n³)</li></ul></li></ul></li></ol><hr><h2 id="🏋️-配套练习">🏋️ 配套练习</h2><ol><li><p><strong>数字菱形阵</strong></p><ul><li>输入：层数n（奇数）</li><li>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> 222</span><br><span class="line">33333</span><br><span class="line"> 222</span><br><span class="line">  1</span><br></pre></td></tr></table></figure></li><li>要求：n=3时输出如上，使用双重循环控制空格和数字</li></ul></li><li><p><strong>质数验证器</strong></p><ul><li>输入：整数m（1&lt;m&lt;1000）</li><li>输出：所有能组成m的质数对（例如16→3+13）</li><li>进阶：输出用时最少的前三对组合</li></ul></li><li><p><strong>数列生成器</strong></p><ul><li>输入：起始值a，差值d，项数n</li><li>输出：等差数列前n项，每行5个数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：2 3 7</span><br><span class="line">输出：</span><br><span class="line">2 5 8 11 14</span><br><span class="line">17 20</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字母金字塔</strong></p><ul><li>输入：大写字母（如E）</li><li>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   ABA</span><br><span class="line">  ABCBA</span><br><span class="line"> ABCDCBA</span><br><span class="line">ABCDEDCBA</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数位分解器</strong></p><ul><li>输入：任意正整数</li><li>输出：各个位数+位数和<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：3141</span><br><span class="line">输出：</span><br><span class="line">千位：3</span><br><span class="line">百位：1</span><br><span class="line">十位：4</span><br><span class="line">个位：1</span><br><span class="line">各位和：9</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L2 - for循环与嵌套逻辑&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;掌握for循环执行流程&lt;/li&gt;
&lt;li&gt;理解循环变量的作用域&lt;/li&gt;
&lt;li&gt;能处理双重循环嵌套问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;🔑-核</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>L1 - C++程序基础架构</title>
    <link href="https://whystars.cn/posts/e7e1.html"/>
    <id>https://whystars.cn/posts/e7e1.html</id>
    <published>2025-05-03T04:09:37.000Z</published>
    <updated>2025-05-03T05:07:28.857Z</updated>
    
    <content type="html"><![CDATA[<h1>L1 - C++程序基础架构</h1><h2 id="🎯-教学目标">🎯 教学目标</h2><ol><li>理解C++程序的基本组成结构</li><li>掌握控制台输入输出的标准写法</li><li>学会声明和使用整型变量</li></ol><h2 id="🔑-核心知识点">🔑 核心知识点</h2><h3 id="程序骨架三要素">程序骨架三要素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 1.包含标准输入输出库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 2.使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;         <span class="comment">// 3.主函数入口</span></span><br><span class="line">    <span class="comment">// 程序逻辑代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">// 返回操作系统状态值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细讲解：</strong></p><ol><li><p><code>#include &lt;iostream&gt;</code>：</p><ul><li>预处理器指令，将输入输出流库的内容包含到当前文件</li><li>必须在使用<code>cout</code>或<code>cin</code>前包含</li><li>类似数学公式中的&quot;=&quot;符号，告诉编译器去哪里找相关定义</li></ul></li><li><p><code>using namespace std</code>：</p><ul><li>命名空间用于避免名称冲突</li><li>std包含所有标准库组件（cout、cin、endl等）</li><li>替代写法：<code>std::cout &lt;&lt; &quot;Hello&quot;;</code>（适用于大型项目）</li></ul></li><li><p><code>main()</code>函数：</p><ul><li>程序执行的唯一入口点</li><li>返回类型必须为int，表示程序结束状态（0表示成功）</li><li>函数体用大括号{}包裹，遵循严格缩进规范</li></ul></li></ol><h3 id="格式化输出技巧">格式化输出技巧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>  <span class="comment">// 新增头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> price = <span class="number">19.8</span>;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Price: $&quot;</span> &lt;&lt; price;</span><br></pre></td></tr></table></figure><p><strong>深度解析：</strong></p><ul><li><code>fixed</code>：固定小数显示方式（禁用科学计数法）</li><li><code>setprecision(n)</code>：设置小数点后有效位数（需配合fixed使用）</li><li>需要包含<code>&lt;iomanip&gt;</code>头文件</li><li>流操作符的链式调用特性：从左到右依次执行</li></ul><h3 id="变量声明与输入">变量声明与输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;           <span class="comment">// 声明整型变量</span></span><br><span class="line">cin &gt;&gt; age;        <span class="comment">// 从键盘获取输入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age; </span><br></pre></td></tr></table></figure><p><strong>关键要点：</strong></p><ol><li><p>变量声明规则：</p><ul><li>必须指定数据类型（int/double/char等）</li><li>遵循标识符命名规则（字母/下划线开头，不含空格）</li><li>建议初始化变量：<code>int age = 0;</code></li></ul></li><li><p>输入输出流：</p><ul><li><code>cin</code>使用<code>&gt;&gt;</code>操作符（数据流向程序）</li><li><code>cout</code>使用<code>&lt;&lt;</code>操作符（数据流向控制台）</li><li><code>endl</code>用于换行并刷新输出缓冲区</li></ul></li></ol><h2 id="💣-易错点详解">💣 易错点详解</h2><ol><li><p><strong>命名空间遗漏</strong></p><ul><li>错误现象：<code>cout &lt;&lt; &quot;Hello&quot;;</code> 编译错误</li><li>解决方案：添加<code>using namespace std;</code>或改为<code>std::cout</code></li></ul></li><li><p><strong>运算符方向混淆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &lt;&lt; a;     <span class="comment">// 错误！应为 &gt;&gt;</span></span><br><span class="line">cout &gt;&gt; <span class="string">&quot;Hi&quot;</span>; <span class="comment">// 错误！应为 &lt;&lt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>未初始化变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count;</span><br><span class="line">cout &lt;&lt; count; <span class="comment">// 输出随机值（危险！）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>格式化输出缺失头文件</strong></p><ul><li>使用<code>setprecision</code>前必须包含<code>&lt;iomanip&gt;</code></li></ul></li><li><p><strong>main函数格式错误</strong></p><ul><li>缺少返回语句</li><li>写成<code>void main()</code>（非标准写法）</li></ul></li></ol><hr><h2 id="🏋️-配套练习">🏋️ 配套练习</h2><ol><li><p><strong>个人信息展示器</strong></p><ul><li>输入：姓名（字符串）、年龄（整数）、身高（浮点数）</li><li>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">======= 个人信息 =======</span><br><span class="line">姓名：[name]</span><br><span class="line">年龄：[age]岁</span><br><span class="line">身高：[height]米</span><br><span class="line">=======================</span><br></pre></td></tr></table></figure></li><li>要求：身高保留2位小数，使用<code>fixed</code>和<code>setprecision</code></li></ul></li><li><p><strong>简易计算器</strong></p><ul><li>输入：两个整数</li><li>输出：四则运算结果</li><li>样例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：8 3</span><br><span class="line">输出：</span><br><span class="line">8+3=11</span><br><span class="line">8-3=5</span><br><span class="line">8 * 3=24</span><br><span class="line">8/3=2（商）余2</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BMI指数计算器</strong></p><ul><li>公式：BMI = 体重(kg) / (身高(m)^2)</li><li>输入：体重、身高</li><li>输出：BMI值（保留1位小数）及等级<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过轻：&lt;18.5</span><br><span class="line">正常：18.5-24</span><br><span class="line">过重：24-28</span><br><span class="line">肥胖：&gt;28</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>超市收据生成器</strong></p><ul><li>输入：商品单价、购买数量</li><li>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** 购物小票 ***</span><br><span class="line">单价：￥15.50</span><br><span class="line">数量：3</span><br><span class="line">总价：￥46.50</span><br><span class="line">==================</span><br></pre></td></tr></table></figure></li><li>要求：价格字段右对齐，总宽度8字符</li></ul></li><li><p><strong>华氏转摄氏进阶版</strong></p><ul><li>输入：华氏温度（可正可负）</li><li>输出：摄氏温度（保留1位小数）及状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当摄氏&gt;35时输出&quot;高温预警&quot;</span><br><span class="line">当摄氏&lt;-10时输出&quot;低温警报&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;L1 - C++程序基础架构&lt;/h1&gt;
&lt;h2 id=&quot;🎯-教学目标&quot;&gt;🎯 教学目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;理解C++程序的基本组成结构&lt;/li&gt;
&lt;li&gt;掌握控制台输入输出的标准写法&lt;/li&gt;
&lt;li&gt;学会声明和使用整型变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="知识体系" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/Level-1/"/>
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="知识体系" scheme="https://whystars.cn/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
    <category term="Level 1" scheme="https://whystars.cn/tags/Level-1/"/>
    
  </entry>
  
  <entry>
    <title>流浪地球2（4K、HD高清）</title>
    <link href="https://whystars.cn/posts/2307715541.html"/>
    <id>https://whystars.cn/posts/2307715541.html</id>
    <published>2023-06-10T06:48:01.000Z</published>
    <updated>2024-02-02T06:57:54.809Z</updated>
    
    <content type="html"><![CDATA[<h1>流浪地球2 电影资源</h1><h2 id="1">简介</h2><p>《流浪地球2》是由郭帆执导，吴京、李雪健、沙溢、宁理、王智、朱颜曼滋领衔主演、刘德华特别演出的科幻灾难电影。该片于2023年1月22日在中国大陆及北美地区同步上映；2023年2月9日在中国港澳地区上映。<br>该片以提出计划将建造1万座行星发动机的时代为故事背景，讲述了“太阳危机”即将来袭，世界陷入一片恐慌之中，万座行星发动机正在建造中，人类将面临末日灾难与生命存续的双重挑战故事。<br>2023年6月2日消息，《流浪地球》官方宣布，《流浪地球 2》将在维也纳进行联合国特别放映。</p><h2 id="2">下载链接</h2><p>huang1111云盘 <a href="https://pan.huang1111.cn/s/WZ9Df3">下载链接</a><br>阿里云盘（比较麻烦） <a href="https://www.aliyundrive.com/s/KEg7w6vaNzj">下载链接</a><br>阿里云盘<strong>下载之后</strong> <a href="#3">查看教程</a></p><h2 id="3">阿里云盘下载后观看教程</h2><ol><li>请下载这两个文件后打开 “<strong>阿里云盘文件伪装&amp;解除v1.1</strong>”</li><li>选择 “<strong>下载后解析</strong>”</li><li>点击 “<strong>选择文件</strong>”</li><li>最后点击 “<strong>点击解析</strong>” 按钮，等待完成即可</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;流浪地球2 电影资源&lt;/h1&gt;
&lt;h2 id=&quot;1&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;《流浪地球2》是由郭帆执导，吴京、李雪健、沙溢、宁理、王智、朱颜曼滋领衔主演、刘德华特别演出的科幻灾难电影。该片于2023年1月22日在中国大陆及北美地区同步上映；2023年2月9日在中国港澳地区</summary>
      
    
    
    
    
    <category term="电影" scheme="https://whystars.cn/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>struct结构体</title>
    <link href="https://whystars.cn/posts/848889115.html"/>
    <id>https://whystars.cn/posts/848889115.html</id>
    <published>2023-05-28T09:07:14.000Z</published>
    <updated>2024-05-12T07:26:15.117Z</updated>
    
    <content type="html"><![CDATA[<h1>struct结构体</h1><h2 id="结构">结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> 结构体名称&#123;</span><br><span class="line">    结构体变量;</span><br><span class="line">&#125;;<span class="comment">//一定要注意分号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    你的结构体名称 变量名;</span><br><span class="line">    变量名.你的结构体内的变量名称或结构体内的函数名称;<span class="comment">//调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> h,w;</span><br><span class="line">&#125;;<span class="comment">//一定要注意分号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stu[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;stu[i].name&gt;&gt;stu[i].h&gt;&gt;stu[i].w;</span><br><span class="line">        <span class="comment">//依次输入姓名、身高、体重;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setw</span>(<span class="number">4</span>)&lt;&lt;stu[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;stu[i].h&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;stu[i].w&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">//依次输出姓名、身高、体重;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;struct结构体&lt;/h1&gt;
&lt;h2 id=&quot;结构&quot;&gt;结构&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>映像劫持</title>
    <link href="https://whystars.cn/posts/1122620100.html"/>
    <id>https://whystars.cn/posts/1122620100.html</id>
    <published>2023-05-27T06:06:33.000Z</published>
    <updated>2024-02-02T06:57:48.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="映像劫持">映像劫持</h2><h3 id="要点">要点</h3><blockquote><p>劫持路径:<br><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code></p></blockquote><h3 id="添加劫持程序">添加劫持程序</h3><blockquote><p>添加项，重命名为<strong>劫持程序名称</strong></p></blockquote><h3 id="设置劫持程序">设置劫持程序</h3><blockquote><p>添加<code>Debugger</code>字符串</p></blockquote><h3 id="添加想运行的程序">添加想运行的程序</h3><blockquote><p>将字符串的值设为<strong>你想运行的程序（绝对路径）,可以留空</strong></p></blockquote><h3 id="完成">完成</h3><blockquote><p>然后再运行被劫持的程序，你就会发现打开了其他程序，而没有打开被劫持的程序</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;映像劫持&quot;&gt;映像劫持&lt;/h2&gt;
&lt;h3 id=&quot;要点&quot;&gt;要点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;劫持路径:&lt;br&gt;
&lt;code&gt;计算机&#92;HKEY_LOCAL_MACHINE&#92;SOFTWARE&#92;Microsoft&#92;Windows NT&#92;CurrentVers</summary>
      
    
    
    
    
    <category term="注册表" scheme="https://whystars.cn/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
    <category term="技术" scheme="https://whystars.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++高精度减法</title>
    <link href="https://whystars.cn/posts/599784019.html"/>
    <id>https://whystars.cn/posts/599784019.html</id>
    <published>2023-05-27T05:58:52.000Z</published>
    <updated>2024-02-02T06:57:42.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高精度减法"><strong>高精度</strong>减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10001</span>],b[<span class="number">10001</span>],c[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string sta,stb;</span><br><span class="line"><span class="type">int</span> la,lb,lc,i,j,g=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;sta&gt;&gt;stb;</span><br><span class="line">la=sta.<span class="built_in">size</span>();</span><br><span class="line">lb=stb.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(la&lt;lb || (la==lb &amp;&amp; sta&lt;stb))&#123;</span><br><span class="line"><span class="built_in">swap</span>(sta,stb);</span><br><span class="line"><span class="built_in">swap</span>(la,lb);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">lc=la;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;la;i++) a[i]=sta[la-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lb;i++) b[i]=stb[lb-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lc;i++)&#123;</span><br><span class="line">c[i]=a[i]-b[i]-g;</span><br><span class="line"><span class="keyword">if</span>(c[i]&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+=<span class="number">10</span>;</span><br><span class="line">g=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> g=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(lc&gt;<span class="number">1</span> &amp;&amp; c[lc<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">lc--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;c[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高精度减法&quot;&gt;&lt;strong&gt;高精度&lt;/strong&gt;减法&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
    <category term="高精度" scheme="https://whystars.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>dfs回溯框架</title>
    <link href="https://whystars.cn/posts/65824488.html"/>
    <id>https://whystars.cn/posts/65824488.html</id>
    <published>2023-05-27T05:50:37.000Z</published>
    <updated>2024-02-02T06:57:30.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dfs回溯框架">dfs回溯框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">using</span> namesapce std;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(范围)&#123;</span><br><span class="line">        <span class="keyword">if</span>(找到解或结束了)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(在范围内)&#123;</span><br><span class="line">            做标记;</span><br><span class="line">            <span class="built_in">dfs</span>(传参);</span><br><span class="line">            抹除标记;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">dfs</span>(传参);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&quot;. . .&quot;为<strong>其他代码</strong>部分</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;dfs回溯框架&quot;&gt;dfs回溯框架&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
    <category term="dfs" scheme="https://whystars.cn/tags/dfs/"/>
    
    <category term="c++" scheme="https://whystars.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客的创建与撰写</title>
    <link href="https://whystars.cn/posts/840339277.html"/>
    <id>https://whystars.cn/posts/840339277.html</id>
    <published>2023-05-26T12:44:29.000Z</published>
    <updated>2025-05-03T04:08:10.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客的创建与撰写">博客的创建与撰写</h2><h3 id="blog问题解决">blog问题解决</h3><ul><li>butterfly出现页面出现<code>extends includes/layout.pug...</code>的解决方法:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><ul><li>推送到GitHub Pages</li></ul><ol><li>首先安装<strong>hexo-deployer-git</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li>然后修改<strong>blog目录下的</strong><code>_config.yml</code> 文件末尾的 <code>Deploy</code> 部分，修改成如下：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol start="3"><li>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</li></ol><hr><h3 id="blog技巧">blog技巧</h3><h4 id="制作blog流程：">制作blog流程：</h4><ol><li>生成初始blog页面</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><ol start="2"><li>然后进入blog页面文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><ol start="3"><li>安装组件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>现在就可以开始制作啦！</p></blockquote><hr><h4 id="启用主题">启用主题</h4><blockquote><p>在<strong>blog目录下的</strong><code>_config.yml</code>中修改<code>themes:xxx</code>为<code>themes:你的主题名</code></p></blockquote><ul><li>主题安装后（使用npm的情况下）文件在<strong>组件文件夹里</strong></li></ul><hr><h4 id="文章">文章</h4><blockquote><p>创建文章<code>hexo new &quot;文章名&quot;</code></p><p>修改好后按如下操作</p></blockquote><h4 id="文章内容">文章内容</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 日期（一般不用修改）</span><br><span class="line">layout: 布局</span><br><span class="line">updated: 更新日期</span><br><span class="line">tags: 标签</span><br><span class="line"><span class="section">categories: 分类</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">文章正文（markdown语法）</span><br></pre></td></tr></table></figure><h4 id="提交">提交</h4><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>hexo clean</code></td><td style="text-align:center">清除<strong>已经生成的</strong></td></tr><tr><td style="text-align:center"><code>hexo g</code></td><td style="text-align:center">生成页面</td></tr><tr><td style="text-align:center"><code>hexo d</code></td><td style="text-align:center">提交到<strong>Github Pages</strong>上</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;博客的创建与撰写&quot;&gt;博客的创建与撰写&lt;/h2&gt;
&lt;h3 id=&quot;blog问题解决&quot;&gt;blog问题解决&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;butterfly出现页面出现&lt;code&gt;extends includes/layout.pug...&lt;/code&gt;的解决方法:&lt;/l</summary>
      
    
    
    
    
    <category term="博客" scheme="https://whystars.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
